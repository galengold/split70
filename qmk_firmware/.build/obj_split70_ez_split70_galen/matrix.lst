   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.init_cols,"ax",@progbits
  12               	init_cols:
  13               	.LFB121:
  14               		.file 1 "keyboards/split70/ez/matrix.c"
   1:keyboards/split70/ez/matrix.c **** /*
   2:keyboards/split70/ez/matrix.c **** 
   3:keyboards/split70/ez/matrix.c **** Note for ErgoDox EZ customizers: Here be dragons!
   4:keyboards/split70/ez/matrix.c **** This is not a file you want to be messing with.
   5:keyboards/split70/ez/matrix.c **** All of the interesting stuff for you is under keymaps/ :)
   6:keyboards/split70/ez/matrix.c **** Love, Erez
   7:keyboards/split70/ez/matrix.c **** 
   8:keyboards/split70/ez/matrix.c **** Copyright 2013 Oleg Kostyuk <cub.uanic@gmail.com>
   9:keyboards/split70/ez/matrix.c **** 
  10:keyboards/split70/ez/matrix.c **** This program is free software: you can redistribute it and/or modify
  11:keyboards/split70/ez/matrix.c **** it under the terms of the GNU General Public License as published by
  12:keyboards/split70/ez/matrix.c **** the Free Software Foundation, either version 2 of the License, or
  13:keyboards/split70/ez/matrix.c **** (at your option) any later version.
  14:keyboards/split70/ez/matrix.c **** 
  15:keyboards/split70/ez/matrix.c **** This program is distributed in the hope that it will be useful,
  16:keyboards/split70/ez/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  17:keyboards/split70/ez/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  18:keyboards/split70/ez/matrix.c **** GNU General Public License for more details.
  19:keyboards/split70/ez/matrix.c **** 
  20:keyboards/split70/ez/matrix.c **** You should have received a copy of the GNU General Public License
  21:keyboards/split70/ez/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  22:keyboards/split70/ez/matrix.c **** */
  23:keyboards/split70/ez/matrix.c **** 
  24:keyboards/split70/ez/matrix.c **** /*
  25:keyboards/split70/ez/matrix.c ****  * scan matrix
  26:keyboards/split70/ez/matrix.c ****  */
  27:keyboards/split70/ez/matrix.c **** #include <stdint.h>
  28:keyboards/split70/ez/matrix.c **** #include <stdbool.h>
  29:keyboards/split70/ez/matrix.c **** #include <avr/io.h>
  30:keyboards/split70/ez/matrix.c **** #include "wait.h"
  31:keyboards/split70/ez/matrix.c **** #include "action_layer.h"
  32:keyboards/split70/ez/matrix.c **** #include "print.h"
  33:keyboards/split70/ez/matrix.c **** #include "debug.h"
  34:keyboards/split70/ez/matrix.c **** #include "util.h"
  35:keyboards/split70/ez/matrix.c **** #include "matrix.h"
  36:keyboards/split70/ez/matrix.c **** #include "ez.h"
  37:keyboards/split70/ez/matrix.c **** #include "i2cmaster.h"
  38:keyboards/split70/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
  39:keyboards/split70/ez/matrix.c **** #include  "timer.h"
  40:keyboards/split70/ez/matrix.c **** #endif
  41:keyboards/split70/ez/matrix.c **** 
  42:keyboards/split70/ez/matrix.c **** /*
  43:keyboards/split70/ez/matrix.c ****  * This constant define not debouncing time in msecs, but amount of matrix
  44:keyboards/split70/ez/matrix.c ****  * scan loops which should be made to get stable debounced results.
  45:keyboards/split70/ez/matrix.c ****  *
  46:keyboards/split70/ez/matrix.c ****  * On Ergodox matrix scan rate is relatively low, because of slow I2C.
  47:keyboards/split70/ez/matrix.c ****  * Now it's only 317 scans/second, or about 3.15 msec/scan.
  48:keyboards/split70/ez/matrix.c ****  * According to Cherry specs, debouncing time is 5 msec.
  49:keyboards/split70/ez/matrix.c ****  *
  50:keyboards/split70/ez/matrix.c ****  * And so, there is no sense to have DEBOUNCE higher than 2.
  51:keyboards/split70/ez/matrix.c ****  */
  52:keyboards/split70/ez/matrix.c **** 
  53:keyboards/split70/ez/matrix.c **** #ifndef DEBOUNCE
  54:keyboards/split70/ez/matrix.c **** #   define DEBOUNCE	5
  55:keyboards/split70/ez/matrix.c **** #endif
  56:keyboards/split70/ez/matrix.c **** static uint8_t debouncing = DEBOUNCE;
  57:keyboards/split70/ez/matrix.c **** 
  58:keyboards/split70/ez/matrix.c **** /* matrix state(1:on, 0:off) */
  59:keyboards/split70/ez/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  60:keyboards/split70/ez/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  61:keyboards/split70/ez/matrix.c **** 
  62:keyboards/split70/ez/matrix.c **** static matrix_row_t read_cols(uint8_t row);
  63:keyboards/split70/ez/matrix.c **** static void init_cols(void);
  64:keyboards/split70/ez/matrix.c **** static void unselect_rows(void);
  65:keyboards/split70/ez/matrix.c **** static void select_row(uint8_t row);
  66:keyboards/split70/ez/matrix.c **** 
  67:keyboards/split70/ez/matrix.c **** static uint8_t mcp23018_reset_loop;
  68:keyboards/split70/ez/matrix.c **** 
  69:keyboards/split70/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
  70:keyboards/split70/ez/matrix.c **** uint32_t matrix_timer;
  71:keyboards/split70/ez/matrix.c **** uint32_t matrix_scan_count;
  72:keyboards/split70/ez/matrix.c **** #endif
  73:keyboards/split70/ez/matrix.c **** 
  74:keyboards/split70/ez/matrix.c **** 
  75:keyboards/split70/ez/matrix.c **** __attribute__ ((weak))
  76:keyboards/split70/ez/matrix.c **** void matrix_init_user(void) {}
  77:keyboards/split70/ez/matrix.c **** 
  78:keyboards/split70/ez/matrix.c **** __attribute__ ((weak))
  79:keyboards/split70/ez/matrix.c **** void matrix_scan_user(void) {}
  80:keyboards/split70/ez/matrix.c **** 
  81:keyboards/split70/ez/matrix.c **** __attribute__ ((weak))
  82:keyboards/split70/ez/matrix.c **** void matrix_init_kb(void) {
  83:keyboards/split70/ez/matrix.c ****   matrix_init_user();
  84:keyboards/split70/ez/matrix.c **** }
  85:keyboards/split70/ez/matrix.c **** 
  86:keyboards/split70/ez/matrix.c **** __attribute__ ((weak))
  87:keyboards/split70/ez/matrix.c **** void matrix_scan_kb(void) {
  88:keyboards/split70/ez/matrix.c ****   matrix_scan_user();
  89:keyboards/split70/ez/matrix.c **** }
  90:keyboards/split70/ez/matrix.c **** 
  91:keyboards/split70/ez/matrix.c **** inline
  92:keyboards/split70/ez/matrix.c **** uint8_t matrix_rows(void)
  93:keyboards/split70/ez/matrix.c **** {
  94:keyboards/split70/ez/matrix.c ****     return MATRIX_ROWS;
  95:keyboards/split70/ez/matrix.c **** }
  96:keyboards/split70/ez/matrix.c **** 
  97:keyboards/split70/ez/matrix.c **** inline
  98:keyboards/split70/ez/matrix.c **** uint8_t matrix_cols(void)
  99:keyboards/split70/ez/matrix.c **** {
 100:keyboards/split70/ez/matrix.c ****     return MATRIX_COLS;
 101:keyboards/split70/ez/matrix.c **** }
 102:keyboards/split70/ez/matrix.c **** 
 103:keyboards/split70/ez/matrix.c **** void matrix_init(void)
 104:keyboards/split70/ez/matrix.c **** {
 105:keyboards/split70/ez/matrix.c ****     // initialize row and col
 106:keyboards/split70/ez/matrix.c **** 
 107:keyboards/split70/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 108:keyboards/split70/ez/matrix.c **** 
 109:keyboards/split70/ez/matrix.c **** 
 110:keyboards/split70/ez/matrix.c ****     unselect_rows();
 111:keyboards/split70/ez/matrix.c ****     init_cols();
 112:keyboards/split70/ez/matrix.c **** 
 113:keyboards/split70/ez/matrix.c ****     // initialize matrix state: all keys off
 114:keyboards/split70/ez/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 115:keyboards/split70/ez/matrix.c ****         matrix[i] = 0;
 116:keyboards/split70/ez/matrix.c ****         matrix_debouncing[i] = 0;
 117:keyboards/split70/ez/matrix.c ****     }
 118:keyboards/split70/ez/matrix.c **** 
 119:keyboards/split70/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 120:keyboards/split70/ez/matrix.c ****     matrix_timer = timer_read32();
 121:keyboards/split70/ez/matrix.c ****     matrix_scan_count = 0;
 122:keyboards/split70/ez/matrix.c **** #endif
 123:keyboards/split70/ez/matrix.c **** 
 124:keyboards/split70/ez/matrix.c ****     matrix_init_quantum();
 125:keyboards/split70/ez/matrix.c **** 
 126:keyboards/split70/ez/matrix.c **** }
 127:keyboards/split70/ez/matrix.c **** 
 128:keyboards/split70/ez/matrix.c **** void matrix_power_up(void) {
 129:keyboards/split70/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 130:keyboards/split70/ez/matrix.c **** 
 131:keyboards/split70/ez/matrix.c ****     unselect_rows();
 132:keyboards/split70/ez/matrix.c ****     init_cols();
 133:keyboards/split70/ez/matrix.c **** 
 134:keyboards/split70/ez/matrix.c ****     // initialize matrix state: all keys off
 135:keyboards/split70/ez/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 136:keyboards/split70/ez/matrix.c ****         matrix[i] = 0;
 137:keyboards/split70/ez/matrix.c ****         matrix_debouncing[i] = 0;
 138:keyboards/split70/ez/matrix.c ****     }
 139:keyboards/split70/ez/matrix.c **** 
 140:keyboards/split70/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 141:keyboards/split70/ez/matrix.c ****     matrix_timer = timer_read32();
 142:keyboards/split70/ez/matrix.c ****     matrix_scan_count = 0;
 143:keyboards/split70/ez/matrix.c **** #endif
 144:keyboards/split70/ez/matrix.c **** 
 145:keyboards/split70/ez/matrix.c **** }
 146:keyboards/split70/ez/matrix.c **** 
 147:keyboards/split70/ez/matrix.c **** uint8_t matrix_scan(void)
 148:keyboards/split70/ez/matrix.c **** {
 149:keyboards/split70/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 150:keyboards/split70/ez/matrix.c ****         if (++mcp23018_reset_loop == 0) {
 151:keyboards/split70/ez/matrix.c ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
 152:keyboards/split70/ez/matrix.c ****             // this will be approx bit more frequent than once per second
 153:keyboards/split70/ez/matrix.c ****             print("trying to reset mcp23018\n");
 154:keyboards/split70/ez/matrix.c ****             mcp23018_status = init_mcp23018();
 155:keyboards/split70/ez/matrix.c ****             if (mcp23018_status) {
 156:keyboards/split70/ez/matrix.c ****                 print("left side not responding\n");
 157:keyboards/split70/ez/matrix.c ****             } else {
 158:keyboards/split70/ez/matrix.c ****                 print("left side attached\n");
 159:keyboards/split70/ez/matrix.c ****             }
 160:keyboards/split70/ez/matrix.c ****         }
 161:keyboards/split70/ez/matrix.c ****     }
 162:keyboards/split70/ez/matrix.c **** 
 163:keyboards/split70/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 164:keyboards/split70/ez/matrix.c ****     matrix_scan_count++;
 165:keyboards/split70/ez/matrix.c **** 
 166:keyboards/split70/ez/matrix.c ****     uint32_t timer_now = timer_read32();
 167:keyboards/split70/ez/matrix.c ****     if (TIMER_DIFF_32(timer_now, matrix_timer)>1000) {
 168:keyboards/split70/ez/matrix.c ****         print("matrix scan frequency: ");
 169:keyboards/split70/ez/matrix.c ****         pdec(matrix_scan_count);
 170:keyboards/split70/ez/matrix.c ****         print("\n");
 171:keyboards/split70/ez/matrix.c **** 
 172:keyboards/split70/ez/matrix.c ****         matrix_timer = timer_now;
 173:keyboards/split70/ez/matrix.c ****         matrix_scan_count = 0;
 174:keyboards/split70/ez/matrix.c ****     }
 175:keyboards/split70/ez/matrix.c **** #endif
 176:keyboards/split70/ez/matrix.c **** 
 177:keyboards/split70/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 178:keyboards/split70/ez/matrix.c ****         select_row(i);
 179:keyboards/split70/ez/matrix.c ****         wait_us(30);  // without this wait read unstable value.
 180:keyboards/split70/ez/matrix.c ****         matrix_row_t cols = read_cols(i);
 181:keyboards/split70/ez/matrix.c ****         if (matrix_debouncing[i] != cols) {
 182:keyboards/split70/ez/matrix.c ****             matrix_debouncing[i] = cols;
 183:keyboards/split70/ez/matrix.c ****             if (debouncing) {
 184:keyboards/split70/ez/matrix.c ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 185:keyboards/split70/ez/matrix.c ****             }
 186:keyboards/split70/ez/matrix.c ****             debouncing = DEBOUNCE;
 187:keyboards/split70/ez/matrix.c ****         }
 188:keyboards/split70/ez/matrix.c ****         unselect_rows();
 189:keyboards/split70/ez/matrix.c ****     }
 190:keyboards/split70/ez/matrix.c **** 
 191:keyboards/split70/ez/matrix.c ****     if (debouncing) {
 192:keyboards/split70/ez/matrix.c ****         if (--debouncing) {
 193:keyboards/split70/ez/matrix.c ****             wait_us(1);
 194:keyboards/split70/ez/matrix.c ****             // this should be wait_ms(1) but has been left as-is at EZ's request
 195:keyboards/split70/ez/matrix.c ****         } else {
 196:keyboards/split70/ez/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 197:keyboards/split70/ez/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 198:keyboards/split70/ez/matrix.c ****             }
 199:keyboards/split70/ez/matrix.c ****         }
 200:keyboards/split70/ez/matrix.c ****     }
 201:keyboards/split70/ez/matrix.c **** 
 202:keyboards/split70/ez/matrix.c ****     matrix_scan_quantum();
 203:keyboards/split70/ez/matrix.c **** 
 204:keyboards/split70/ez/matrix.c ****     return 1;
 205:keyboards/split70/ez/matrix.c **** }
 206:keyboards/split70/ez/matrix.c **** 
 207:keyboards/split70/ez/matrix.c **** bool matrix_is_modified(void)
 208:keyboards/split70/ez/matrix.c **** {
 209:keyboards/split70/ez/matrix.c ****     if (debouncing) return false;
 210:keyboards/split70/ez/matrix.c ****     return true;
 211:keyboards/split70/ez/matrix.c **** }
 212:keyboards/split70/ez/matrix.c **** 
 213:keyboards/split70/ez/matrix.c **** inline
 214:keyboards/split70/ez/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 215:keyboards/split70/ez/matrix.c **** {
 216:keyboards/split70/ez/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 217:keyboards/split70/ez/matrix.c **** }
 218:keyboards/split70/ez/matrix.c **** 
 219:keyboards/split70/ez/matrix.c **** inline
 220:keyboards/split70/ez/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 221:keyboards/split70/ez/matrix.c **** {
 222:keyboards/split70/ez/matrix.c ****     return matrix[row];
 223:keyboards/split70/ez/matrix.c **** }
 224:keyboards/split70/ez/matrix.c **** 
 225:keyboards/split70/ez/matrix.c **** void matrix_print(void)
 226:keyboards/split70/ez/matrix.c **** {
 227:keyboards/split70/ez/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 228:keyboards/split70/ez/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 229:keyboards/split70/ez/matrix.c ****         phex(row); print(": ");
 230:keyboards/split70/ez/matrix.c ****         pbin_reverse16(matrix_get_row(row));
 231:keyboards/split70/ez/matrix.c ****         print("\n");
 232:keyboards/split70/ez/matrix.c ****     }
 233:keyboards/split70/ez/matrix.c **** }
 234:keyboards/split70/ez/matrix.c **** 
 235:keyboards/split70/ez/matrix.c **** uint8_t matrix_key_count(void)
 236:keyboards/split70/ez/matrix.c **** {
 237:keyboards/split70/ez/matrix.c ****     uint8_t count = 0;
 238:keyboards/split70/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 239:keyboards/split70/ez/matrix.c ****         count += bitpop16(matrix[i]);
 240:keyboards/split70/ez/matrix.c ****     }
 241:keyboards/split70/ez/matrix.c ****     return count;
 242:keyboards/split70/ez/matrix.c **** }
 243:keyboards/split70/ez/matrix.c **** 
 244:keyboards/split70/ez/matrix.c **** /* Column pin configuration
 245:keyboards/split70/ez/matrix.c ****  *
 246:keyboards/split70/ez/matrix.c ****  * Teensy
 247:keyboards/split70/ez/matrix.c ****  * col: 0   1   2   3   4   5
 248:keyboards/split70/ez/matrix.c ****  * pin: F7  F6  F5  F4  F1  F0
 249:keyboards/split70/ez/matrix.c ****  *
 250:keyboards/split70/ez/matrix.c ****  * MCP23018
 251:keyboards/split70/ez/matrix.c ****  * col: 0   1   2   3   4   5
 252:keyboards/split70/ez/matrix.c ****  * pin: B5  B4  B3  B2  B1  B0
 253:keyboards/split70/ez/matrix.c ****  */
 254:keyboards/split70/ez/matrix.c **** static void  init_cols(void)
 255:keyboards/split70/ez/matrix.c **** {
  15               		.loc 1 255 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 256:keyboards/split70/ez/matrix.c ****     // init on mcp23018
 257:keyboards/split70/ez/matrix.c ****     // not needed, already done as part of init_mcp23018()
 258:keyboards/split70/ez/matrix.c **** 
 259:keyboards/split70/ez/matrix.c ****     // init on teensy
 260:keyboards/split70/ez/matrix.c ****     // Input with pull-up(DDR:0, PORT:1)
 261:keyboards/split70/ez/matrix.c ****     DDRF  &= ~0xF3;
  21               		.loc 1 261 0
  22 0000 80B3      		in r24,0x10
  23 0002 8C70      		andi r24,lo8(12)
  24 0004 80BB      		out 0x10,r24
 262:keyboards/split70/ez/matrix.c ****     PORTF |=  0xF3;
  25               		.loc 1 262 0
  26 0006 81B3      		in r24,0x11
  27 0008 836F      		ori r24,lo8(-13)
  28 000a 81BB      		out 0x11,r24
  29 000c 0895      		ret
  30               		.cfi_endproc
  31               	.LFE121:
  33               		.section	.text.unselect_rows,"ax",@progbits
  35               	unselect_rows:
  36               	.LFB123:
 263:keyboards/split70/ez/matrix.c **** }
 264:keyboards/split70/ez/matrix.c **** 
 265:keyboards/split70/ez/matrix.c **** static matrix_row_t read_cols(uint8_t row)
 266:keyboards/split70/ez/matrix.c **** {
 267:keyboards/split70/ez/matrix.c ****     if (row < 7) {
 268:keyboards/split70/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 269:keyboards/split70/ez/matrix.c ****             return 0;
 270:keyboards/split70/ez/matrix.c ****         } else {
 271:keyboards/split70/ez/matrix.c ****             uint8_t data = 0;
 272:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 273:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 274:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 275:keyboards/split70/ez/matrix.c ****             data = i2c_readNak();
 276:keyboards/split70/ez/matrix.c ****             data = ~data;
 277:keyboards/split70/ez/matrix.c ****         out:
 278:keyboards/split70/ez/matrix.c ****             i2c_stop();
 279:keyboards/split70/ez/matrix.c ****             return data;
 280:keyboards/split70/ez/matrix.c ****         }
 281:keyboards/split70/ez/matrix.c ****     } else {
 282:keyboards/split70/ez/matrix.c ****         // read from teensy
 283:keyboards/split70/ez/matrix.c ****         return
 284:keyboards/split70/ez/matrix.c ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 285:keyboards/split70/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 286:keyboards/split70/ez/matrix.c ****             (PINF&(1<<4) ? 0 : (1<<2)) |
 287:keyboards/split70/ez/matrix.c ****             (PINF&(1<<5) ? 0 : (1<<3)) |
 288:keyboards/split70/ez/matrix.c ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 289:keyboards/split70/ez/matrix.c ****             (PINF&(1<<7) ? 0 : (1<<5)) ;
 290:keyboards/split70/ez/matrix.c ****     }
 291:keyboards/split70/ez/matrix.c **** }
 292:keyboards/split70/ez/matrix.c **** 
 293:keyboards/split70/ez/matrix.c **** /* Row pin configuration
 294:keyboards/split70/ez/matrix.c ****  *
 295:keyboards/split70/ez/matrix.c ****  * Teensy
 296:keyboards/split70/ez/matrix.c ****  * row: 6   7   8   9   10  11
 297:keyboards/split70/ez/matrix.c ****  * pin: B0  B1  B2  B3  D2  D3
 298:keyboards/split70/ez/matrix.c ****  *
 299:keyboards/split70/ez/matrix.c ****  * MCP23018
 300:keyboards/split70/ez/matrix.c ****  * row: 0   1   2   3   4   5 
 301:keyboards/split70/ez/matrix.c ****  * pin: A0  A1  A2  A3  A4  A5
 302:keyboards/split70/ez/matrix.c ****  */
 303:keyboards/split70/ez/matrix.c **** static void unselect_rows(void)
 304:keyboards/split70/ez/matrix.c **** {
  37               		.loc 1 304 0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
 305:keyboards/split70/ez/matrix.c ****     // unselect on mcp23018
 306:keyboards/split70/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
  43               		.loc 1 306 0
  44 0000 8091 0000 		lds r24,mcp23018_status
  45 0004 8111      		cpse r24,__zero_reg__
  46 0006 00C0      		rjmp .L3
 307:keyboards/split70/ez/matrix.c ****         // do nothing
 308:keyboards/split70/ez/matrix.c ****     } else {
 309:keyboards/split70/ez/matrix.c ****         // set all rows hi-Z : 1
 310:keyboards/split70/ez/matrix.c ****         mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
  47               		.loc 1 310 0
  48 0008 80E4      		ldi r24,lo8(64)
  49 000a 0E94 0000 		call i2c_start
  50               	.LVL0:
  51 000e 8093 0000 		sts mcp23018_status,r24
  52 0012 8111      		cpse r24,__zero_reg__
  53 0014 00C0      		rjmp .L5
 311:keyboards/split70/ez/matrix.c ****         mcp23018_status = i2c_write(GPIOA);             if (mcp23018_status) goto out;
  54               		.loc 1 311 0
  55 0016 82E1      		ldi r24,lo8(18)
  56 0018 0E94 0000 		call i2c_write
  57               	.LVL1:
  58 001c 8093 0000 		sts mcp23018_status,r24
  59 0020 8111      		cpse r24,__zero_reg__
  60 0022 00C0      		rjmp .L5
 312:keyboards/split70/ez/matrix.c ****         mcp23018_status = i2c_write( 0xFF
  61               		.loc 1 312 0
  62 0024 8FEF      		ldi r24,lo8(-1)
  63 0026 0E94 0000 		call i2c_write
  64               	.LVL2:
  65 002a 8093 0000 		sts mcp23018_status,r24
  66               	.L5:
 313:keyboards/split70/ez/matrix.c ****                               & ~(0<<7)
 314:keyboards/split70/ez/matrix.c ****                           );                            if (mcp23018_status) goto out;
 315:keyboards/split70/ez/matrix.c ****     out:
 316:keyboards/split70/ez/matrix.c ****         i2c_stop();
  67               		.loc 1 316 0
  68 002e 0E94 0000 		call i2c_stop
  69               	.LVL3:
  70               	.L3:
 317:keyboards/split70/ez/matrix.c ****     }
 318:keyboards/split70/ez/matrix.c **** 
 319:keyboards/split70/ez/matrix.c ****     // unselect on teensy
 320:keyboards/split70/ez/matrix.c ****     // Hi-Z(DDR:0, PORT:0) to unselect
 321:keyboards/split70/ez/matrix.c ****     DDRB  &= ~0x0F;
  71               		.loc 1 321 0
  72 0032 84B1      		in r24,0x4
  73 0034 807F      		andi r24,lo8(-16)
  74 0036 84B9      		out 0x4,r24
 322:keyboards/split70/ez/matrix.c ****     PORTB &= ~0x0F;
  75               		.loc 1 322 0
  76 0038 85B1      		in r24,0x5
  77 003a 807F      		andi r24,lo8(-16)
  78 003c 85B9      		out 0x5,r24
 323:keyboards/split70/ez/matrix.c ****     DDRD  &= ~0x0C;
  79               		.loc 1 323 0
  80 003e 8AB1      		in r24,0xa
  81 0040 837F      		andi r24,lo8(-13)
  82 0042 8AB9      		out 0xa,r24
 324:keyboards/split70/ez/matrix.c ****     PORTD &= ~0x0C;
  83               		.loc 1 324 0
  84 0044 8BB1      		in r24,0xb
  85 0046 837F      		andi r24,lo8(-13)
  86 0048 8BB9      		out 0xb,r24
  87 004a 0895      		ret
  88               		.cfi_endproc
  89               	.LFE123:
  91               		.section	.text.matrix_scan_user,"ax",@progbits
  92               		.weak	matrix_scan_user
  94               	matrix_scan_user:
  95               	.LFB108:
  79:keyboards/split70/ez/matrix.c **** 
  96               		.loc 1 79 0
  97               		.cfi_startproc
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 102 0000 0895      		ret
 103               		.cfi_endproc
 104               	.LFE108:
 106               		.set	matrix_scan_user.localalias.0,matrix_scan_user
 107               		.section	.text.matrix_init_user,"ax",@progbits
 108               		.weak	matrix_init_user
 110               	matrix_init_user:
 111               	.LFB126:
 112               		.cfi_startproc
 113               	/* prologue: function */
 114               	/* frame size = 0 */
 115               	/* stack size = 0 */
 116               	.L__stack_usage = 0
 117 0000 0C94 0000 		jmp matrix_scan_user.localalias.0
 118               		.cfi_endproc
 119               	.LFE126:
 121               		.section	.text.matrix_init_kb,"ax",@progbits
 122               		.weak	matrix_init_kb
 124               	matrix_init_kb:
 125               	.LFB109:
  82:keyboards/split70/ez/matrix.c ****   matrix_init_user();
 126               		.loc 1 82 0
 127               		.cfi_startproc
 128               	/* prologue: function */
 129               	/* frame size = 0 */
 130               	/* stack size = 0 */
 131               	.L__stack_usage = 0
  83:keyboards/split70/ez/matrix.c **** }
 132               		.loc 1 83 0
 133 0000 0C94 0000 		jmp matrix_init_user
 134               	.LVL4:
 135               		.cfi_endproc
 136               	.LFE109:
 138               		.section	.text.matrix_scan_kb,"ax",@progbits
 139               		.weak	matrix_scan_kb
 141               	matrix_scan_kb:
 142               	.LFB110:
  87:keyboards/split70/ez/matrix.c ****   matrix_scan_user();
 143               		.loc 1 87 0
 144               		.cfi_startproc
 145               	/* prologue: function */
 146               	/* frame size = 0 */
 147               	/* stack size = 0 */
 148               	.L__stack_usage = 0
  88:keyboards/split70/ez/matrix.c **** }
 149               		.loc 1 88 0
 150 0000 0C94 0000 		jmp matrix_scan_user
 151               	.LVL5:
 152               		.cfi_endproc
 153               	.LFE110:
 155               		.section	.text.matrix_rows,"ax",@progbits
 156               	.global	matrix_rows
 158               	matrix_rows:
 159               	.LFB111:
  93:keyboards/split70/ez/matrix.c ****     return MATRIX_ROWS;
 160               		.loc 1 93 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
  95:keyboards/split70/ez/matrix.c **** 
 166               		.loc 1 95 0
 167 0000 8CE0      		ldi r24,lo8(12)
 168 0002 0895      		ret
 169               		.cfi_endproc
 170               	.LFE111:
 172               		.section	.text.matrix_cols,"ax",@progbits
 173               	.global	matrix_cols
 175               	matrix_cols:
 176               	.LFB112:
  99:keyboards/split70/ez/matrix.c ****     return MATRIX_COLS;
 177               		.loc 1 99 0
 178               		.cfi_startproc
 179               	/* prologue: function */
 180               	/* frame size = 0 */
 181               	/* stack size = 0 */
 182               	.L__stack_usage = 0
 101:keyboards/split70/ez/matrix.c **** 
 183               		.loc 1 101 0
 184 0000 86E0      		ldi r24,lo8(6)
 185 0002 0895      		ret
 186               		.cfi_endproc
 187               	.LFE112:
 189               		.section	.text.matrix_init,"ax",@progbits
 190               	.global	matrix_init
 192               	matrix_init:
 193               	.LFB113:
 104:keyboards/split70/ez/matrix.c ****     // initialize row and col
 194               		.loc 1 104 0
 195               		.cfi_startproc
 196               	/* prologue: function */
 197               	/* frame size = 0 */
 198               	/* stack size = 0 */
 199               	.L__stack_usage = 0
 107:keyboards/split70/ez/matrix.c **** 
 200               		.loc 1 107 0
 201 0000 0E94 0000 		call init_mcp23018
 202               	.LVL6:
 203 0004 8093 0000 		sts mcp23018_status,r24
 110:keyboards/split70/ez/matrix.c ****     init_cols();
 204               		.loc 1 110 0
 205 0008 0E94 0000 		call unselect_rows
 206               	.LVL7:
 111:keyboards/split70/ez/matrix.c **** 
 207               		.loc 1 111 0
 208 000c 0E94 0000 		call init_cols
 209               	.LVL8:
 210 0010 E0E0      		ldi r30,lo8(matrix)
 211 0012 F0E0      		ldi r31,hi8(matrix)
 212 0014 A0E0      		ldi r26,lo8(matrix_debouncing)
 213 0016 B0E0      		ldi r27,hi8(matrix_debouncing)
 214               	.LVL9:
 215               	.L14:
 216               	.LBB9:
 115:keyboards/split70/ez/matrix.c ****         matrix_debouncing[i] = 0;
 217               		.loc 1 115 0 discriminator 3
 218 0018 1192      		st Z+,__zero_reg__
 219               	.LVL10:
 116:keyboards/split70/ez/matrix.c ****     }
 220               		.loc 1 116 0 discriminator 3
 221 001a 1D92      		st X+,__zero_reg__
 222               	.LVL11:
 114:keyboards/split70/ez/matrix.c ****         matrix[i] = 0;
 223               		.loc 1 114 0 discriminator 3
 224 001c 80E0      		ldi r24,hi8(matrix+12)
 225 001e E030      		cpi r30,lo8(matrix+12)
 226 0020 F807      		cpc r31,r24
 227 0022 01F4      		brne .L14
 228               	.LBE9:
 124:keyboards/split70/ez/matrix.c **** 
 229               		.loc 1 124 0
 230 0024 0C94 0000 		jmp matrix_init_quantum
 231               	.LVL12:
 232               		.cfi_endproc
 233               	.LFE113:
 235               		.section	.text.matrix_power_up,"ax",@progbits
 236               	.global	matrix_power_up
 238               	matrix_power_up:
 239               	.LFB114:
 128:keyboards/split70/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 240               		.loc 1 128 0
 241               		.cfi_startproc
 242               	/* prologue: function */
 243               	/* frame size = 0 */
 244               	/* stack size = 0 */
 245               	.L__stack_usage = 0
 129:keyboards/split70/ez/matrix.c **** 
 246               		.loc 1 129 0
 247 0000 0E94 0000 		call init_mcp23018
 248               	.LVL13:
 249 0004 8093 0000 		sts mcp23018_status,r24
 131:keyboards/split70/ez/matrix.c ****     init_cols();
 250               		.loc 1 131 0
 251 0008 0E94 0000 		call unselect_rows
 252               	.LVL14:
 132:keyboards/split70/ez/matrix.c **** 
 253               		.loc 1 132 0
 254 000c 0E94 0000 		call init_cols
 255               	.LVL15:
 256 0010 E0E0      		ldi r30,lo8(matrix)
 257 0012 F0E0      		ldi r31,hi8(matrix)
 258 0014 A0E0      		ldi r26,lo8(matrix_debouncing)
 259 0016 B0E0      		ldi r27,hi8(matrix_debouncing)
 260               	.LVL16:
 261               	.L17:
 262               	.LBB10:
 136:keyboards/split70/ez/matrix.c ****         matrix_debouncing[i] = 0;
 263               		.loc 1 136 0 discriminator 3
 264 0018 1192      		st Z+,__zero_reg__
 265               	.LVL17:
 137:keyboards/split70/ez/matrix.c ****     }
 266               		.loc 1 137 0 discriminator 3
 267 001a 1D92      		st X+,__zero_reg__
 268               	.LVL18:
 135:keyboards/split70/ez/matrix.c ****         matrix[i] = 0;
 269               		.loc 1 135 0 discriminator 3
 270 001c 80E0      		ldi r24,hi8(matrix+12)
 271 001e E030      		cpi r30,lo8(matrix+12)
 272 0020 F807      		cpc r31,r24
 273 0022 01F4      		brne .L17
 274               	/* epilogue start */
 275               	.LBE10:
 145:keyboards/split70/ez/matrix.c **** 
 276               		.loc 1 145 0
 277 0024 0895      		ret
 278               		.cfi_endproc
 279               	.LFE114:
 281               		.section	.text.matrix_scan,"ax",@progbits
 282               	.global	matrix_scan
 284               	matrix_scan:
 285               	.LFB115:
 148:keyboards/split70/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 286               		.loc 1 148 0
 287               		.cfi_startproc
 288 0000 AF92      		push r10
 289               	.LCFI0:
 290               		.cfi_def_cfa_offset 3
 291               		.cfi_offset 10, -2
 292 0002 BF92      		push r11
 293               	.LCFI1:
 294               		.cfi_def_cfa_offset 4
 295               		.cfi_offset 11, -3
 296 0004 CF92      		push r12
 297               	.LCFI2:
 298               		.cfi_def_cfa_offset 5
 299               		.cfi_offset 12, -4
 300 0006 DF92      		push r13
 301               	.LCFI3:
 302               		.cfi_def_cfa_offset 6
 303               		.cfi_offset 13, -5
 304 0008 EF92      		push r14
 305               	.LCFI4:
 306               		.cfi_def_cfa_offset 7
 307               		.cfi_offset 14, -6
 308 000a FF92      		push r15
 309               	.LCFI5:
 310               		.cfi_def_cfa_offset 8
 311               		.cfi_offset 15, -7
 312 000c 0F93      		push r16
 313               	.LCFI6:
 314               		.cfi_def_cfa_offset 9
 315               		.cfi_offset 16, -8
 316 000e 1F93      		push r17
 317               	.LCFI7:
 318               		.cfi_def_cfa_offset 10
 319               		.cfi_offset 17, -9
 320 0010 CF93      		push r28
 321               	.LCFI8:
 322               		.cfi_def_cfa_offset 11
 323               		.cfi_offset 28, -10
 324 0012 DF93      		push r29
 325               	.LCFI9:
 326               		.cfi_def_cfa_offset 12
 327               		.cfi_offset 29, -11
 328               	/* prologue: function */
 329               	/* frame size = 0 */
 330               	/* stack size = 10 */
 331               	.L__stack_usage = 10
 149:keyboards/split70/ez/matrix.c ****         if (++mcp23018_reset_loop == 0) {
 332               		.loc 1 149 0
 333 0014 8091 0000 		lds r24,mcp23018_status
 334 0018 8823      		tst r24
 335 001a 01F0      		breq .L21
 150:keyboards/split70/ez/matrix.c ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
 336               		.loc 1 150 0
 337 001c 8091 0000 		lds r24,mcp23018_reset_loop
 338 0020 8F5F      		subi r24,lo8(-(1))
 339 0022 8093 0000 		sts mcp23018_reset_loop,r24
 340 0026 8111      		cpse r24,__zero_reg__
 341 0028 00C0      		rjmp .L21
 154:keyboards/split70/ez/matrix.c ****             if (mcp23018_status) {
 342               		.loc 1 154 0
 343 002a 0E94 0000 		call init_mcp23018
 344               	.LVL19:
 345 002e 8093 0000 		sts mcp23018_status,r24
 346               	.L21:
 347 0032 80E0      		ldi r24,lo8(matrix_debouncing)
 348 0034 C82E      		mov r12,r24
 349 0036 80E0      		ldi r24,hi8(matrix_debouncing)
 350 0038 D82E      		mov r13,r24
 148:keyboards/split70/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 351               		.loc 1 148 0
 352 003a 7601      		movw r14,r12
 353 003c 00E0      		ldi r16,0
 354 003e 10E0      		ldi r17,0
 355               	.LBB23:
 356               	.LBB24:
 357               	.LBB25:
 358               	.LBB26:
 325:keyboards/split70/ez/matrix.c **** }
 326:keyboards/split70/ez/matrix.c **** 
 327:keyboards/split70/ez/matrix.c **** static void select_row(uint8_t row)
 328:keyboards/split70/ez/matrix.c **** {
 329:keyboards/split70/ez/matrix.c ****     if (row < 6) {
 330:keyboards/split70/ez/matrix.c ****         // select on mcp23018
 331:keyboards/split70/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 332:keyboards/split70/ez/matrix.c ****             // do nothing
 333:keyboards/split70/ez/matrix.c ****         } else {
 334:keyboards/split70/ez/matrix.c ****             // set active row low  : 0
 335:keyboards/split70/ez/matrix.c ****             // set other rows hi-Z : 1
 336:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);        if (mcp23018_status) goto out;
 337:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 338:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row)
 359               		.loc 1 338 0
 360 0040 AA24      		clr r10
 361 0042 A394      		inc r10
 362 0044 B12C      		mov r11,__zero_reg__
 363               	.LBE26:
 364               	.LBE25:
 186:keyboards/split70/ez/matrix.c ****         }
 365               		.loc 1 186 0
 366 0046 D5E0      		ldi r29,lo8(5)
 367               	.L46:
 368 0048 C02F      		mov r28,r16
 369               	.LVL20:
 370               	.LBB29:
 371               	.LBB27:
 329:keyboards/split70/ez/matrix.c ****         // select on mcp23018
 372               		.loc 1 329 0
 373 004a 0630      		cpi r16,lo8(6)
 374 004c 00F0      		brlo .+2
 375 004e 00C0      		rjmp .L23
 331:keyboards/split70/ez/matrix.c ****             // do nothing
 376               		.loc 1 331 0
 377 0050 8091 0000 		lds r24,mcp23018_status
 378 0054 8111      		cpse r24,__zero_reg__
 379 0056 00C0      		rjmp .L24
 336:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 380               		.loc 1 336 0
 381 0058 80E4      		ldi r24,lo8(64)
 382 005a 0E94 0000 		call i2c_start
 383               	.LVL21:
 384 005e 8093 0000 		sts mcp23018_status,r24
 385 0062 8111      		cpse r24,__zero_reg__
 386 0064 00C0      		rjmp .L26
 337:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row)
 387               		.loc 1 337 0
 388 0066 82E1      		ldi r24,lo8(18)
 389 0068 0E94 0000 		call i2c_write
 390               	.LVL22:
 391 006c 8093 0000 		sts mcp23018_status,r24
 392 0070 8111      		cpse r24,__zero_reg__
 393 0072 00C0      		rjmp .L26
 394               		.loc 1 338 0
 395 0074 C501      		movw r24,r10
 396 0076 002E      		mov r0,r16
 397 0078 00C0      		rjmp 2f
 398               		1:
 399 007a 880F      		lsl r24
 400               		2:
 401 007c 0A94      		dec r0
 402 007e 02F4      		brpl 1b
 403 0080 8095      		com r24
 404 0082 0E94 0000 		call i2c_write
 405               	.LVL23:
 406 0086 8093 0000 		sts mcp23018_status,r24
 407               	.L26:
 339:keyboards/split70/ez/matrix.c ****                                   & ~(0<<6)
 340:keyboards/split70/ez/matrix.c ****                               );                                if (mcp23018_status) goto out;
 341:keyboards/split70/ez/matrix.c ****         out:
 342:keyboards/split70/ez/matrix.c ****             i2c_stop();
 408               		.loc 1 342 0
 409 008a 0E94 0000 		call i2c_stop
 410               	.LVL24:
 411               	.L24:
 412               	.LBE27:
 413               	.LBE29:
 414               	.LBB30:
 415               	.LBB31:
 416               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 417               		.loc 2 276 0
 418 008e 80EA      		ldi r24,lo8(-96)
 419 0090 8A95      	1:	dec r24
 420 0092 01F4      		brne 1b
 421               	.LVL25:
 422               	.LBE31:
 423               	.LBE30:
 424               	.LBB32:
 425               	.LBB33:
 267:keyboards/split70/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 426               		.loc 1 267 0
 427 0094 C730      		cpi r28,lo8(7)
 428 0096 00F0      		brlo .+2
 429 0098 00C0      		rjmp .L35
 268:keyboards/split70/ez/matrix.c ****             return 0;
 430               		.loc 1 268 0
 431 009a C091 0000 		lds r28,mcp23018_status
 432 009e C111      		cpse r28,__zero_reg__
 433 00a0 00C0      		rjmp .L52
 434               	.LVL26:
 435               	.LBB34:
 272:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 436               		.loc 1 272 0
 437 00a2 80E4      		ldi r24,lo8(64)
 438 00a4 0E94 0000 		call i2c_start
 439               	.LVL27:
 440 00a8 8093 0000 		sts mcp23018_status,r24
 441 00ac 8111      		cpse r24,__zero_reg__
 442 00ae 00C0      		rjmp .L38
 273:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 443               		.loc 1 273 0
 444 00b0 83E1      		ldi r24,lo8(19)
 445 00b2 0E94 0000 		call i2c_write
 446               	.LVL28:
 447 00b6 8093 0000 		sts mcp23018_status,r24
 448 00ba 8111      		cpse r24,__zero_reg__
 449 00bc 00C0      		rjmp .L38
 274:keyboards/split70/ez/matrix.c ****             data = i2c_readNak();
 450               		.loc 1 274 0
 451 00be 81E4      		ldi r24,lo8(65)
 452 00c0 0E94 0000 		call i2c_start
 453               	.LVL29:
 454 00c4 8093 0000 		sts mcp23018_status,r24
 455 00c8 8111      		cpse r24,__zero_reg__
 456 00ca 00C0      		rjmp .L38
 275:keyboards/split70/ez/matrix.c ****             data = ~data;
 457               		.loc 1 275 0
 458 00cc 0E94 0000 		call i2c_readNak
 459               	.LVL30:
 276:keyboards/split70/ez/matrix.c ****         out:
 460               		.loc 1 276 0
 461 00d0 C82F      		mov r28,r24
 462 00d2 C095      		com r28
 463               	.LVL31:
 464               	.L38:
 278:keyboards/split70/ez/matrix.c ****             return data;
 465               		.loc 1 278 0
 466 00d4 0E94 0000 		call i2c_stop
 467               	.LVL32:
 468               	.L36:
 469               	.LBE34:
 470               	.LBE33:
 471               	.LBE32:
 181:keyboards/split70/ez/matrix.c ****             matrix_debouncing[i] = cols;
 472               		.loc 1 181 0
 473 00d8 D701      		movw r26,r14
 474 00da 8C91      		ld r24,X
 475 00dc 8C17      		cp r24,r28
 476 00de 01F0      		breq .L45
 182:keyboards/split70/ez/matrix.c ****             if (debouncing) {
 477               		.loc 1 182 0
 478 00e0 CC93      		st X,r28
 186:keyboards/split70/ez/matrix.c ****         }
 479               		.loc 1 186 0
 480 00e2 D093 0000 		sts debouncing,r29
 481               	.L45:
 188:keyboards/split70/ez/matrix.c ****     }
 482               		.loc 1 188 0 discriminator 2
 483 00e6 0E94 0000 		call unselect_rows
 484               	.LVL33:
 485 00ea 0F5F      		subi r16,-1
 486 00ec 1F4F      		sbci r17,-1
 487               	.LVL34:
 488 00ee BFEF      		ldi r27,-1
 489 00f0 EB1A      		sub r14,r27
 490 00f2 FB0A      		sbc r15,r27
 491               	.LBE24:
 177:keyboards/split70/ez/matrix.c ****         select_row(i);
 492               		.loc 1 177 0 discriminator 2
 493 00f4 0C30      		cpi r16,12
 494 00f6 1105      		cpc r17,__zero_reg__
 495 00f8 01F0      		breq .+2
 496 00fa 00C0      		rjmp .L46
 497               	.LBE23:
 191:keyboards/split70/ez/matrix.c ****         if (--debouncing) {
 498               		.loc 1 191 0
 499 00fc 8091 0000 		lds r24,debouncing
 500 0100 8823      		tst r24
 501 0102 01F0      		breq .L48
 192:keyboards/split70/ez/matrix.c ****             wait_us(1);
 502               		.loc 1 192 0
 503 0104 8150      		subi r24,lo8(-(-1))
 504 0106 8093 0000 		sts debouncing,r24
 505 010a 8823      		tst r24
 506 010c 01F4      		brne .+2
 507 010e 00C0      		rjmp .L49
 508               	.LVL35:
 509               	.LBB39:
 510               	.LBB40:
 511               		.loc 2 276 0
 512 0110 E5E0      		ldi r30,lo8(5)
 513 0112 EA95      	1:	dec r30
 514 0114 01F4      		brne 1b
 515 0116 0000      		nop
 516               	.LVL36:
 517               	.L48:
 518               	.LBE40:
 519               	.LBE39:
 202:keyboards/split70/ez/matrix.c **** 
 520               		.loc 1 202 0
 521 0118 0E94 0000 		call matrix_scan_quantum
 522               	.LVL37:
 205:keyboards/split70/ez/matrix.c **** 
 523               		.loc 1 205 0
 524 011c 81E0      		ldi r24,lo8(1)
 525               	/* epilogue start */
 526 011e DF91      		pop r29
 527 0120 CF91      		pop r28
 528 0122 1F91      		pop r17
 529 0124 0F91      		pop r16
 530               	.LVL38:
 531 0126 FF90      		pop r15
 532 0128 EF90      		pop r14
 533 012a DF90      		pop r13
 534 012c CF90      		pop r12
 535 012e BF90      		pop r11
 536 0130 AF90      		pop r10
 537 0132 0895      		ret
 538               	.LVL39:
 539               	.L23:
 540               	.LBB41:
 541               	.LBB38:
 542               	.LBB36:
 543               	.LBB28:
 343:keyboards/split70/ez/matrix.c ****         }
 344:keyboards/split70/ez/matrix.c ****     } else {
 345:keyboards/split70/ez/matrix.c ****         // select on teensy
 346:keyboards/split70/ez/matrix.c ****         // Output low(DDR:1, PORT:0) to select
 347:keyboards/split70/ez/matrix.c ****         switch (row) {
 544               		.loc 1 347 0
 545 0134 0930      		cpi r16,lo8(9)
 546 0136 01F0      		breq .L29
 547 0138 00F4      		brsh .L30
 548 013a 0730      		cpi r16,lo8(7)
 549 013c 01F0      		breq .L31
 550 013e 0830      		cpi r16,lo8(8)
 551 0140 01F0      		breq .L32
 552               	.L28:
 348:keyboards/split70/ez/matrix.c ****             case 6:
 349:keyboards/split70/ez/matrix.c ****                 DDRB  |= (1<<0);
 553               		.loc 1 349 0
 554 0142 209A      		sbi 0x4,0
 350:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<0);
 555               		.loc 1 350 0
 556 0144 2898      		cbi 0x5,0
 557 0146 00C0      		rjmp .L24
 558               	.L30:
 347:keyboards/split70/ez/matrix.c ****             case 6:
 559               		.loc 1 347 0
 560 0148 0A30      		cpi r16,lo8(10)
 561 014a 01F0      		breq .L33
 562 014c 0B30      		cpi r16,lo8(11)
 563 014e 01F4      		brne .L28
 351:keyboards/split70/ez/matrix.c ****                 break;
 352:keyboards/split70/ez/matrix.c ****             case 7:
 353:keyboards/split70/ez/matrix.c ****                 DDRB  |= (1<<1);
 354:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<1);
 355:keyboards/split70/ez/matrix.c ****                 break;
 356:keyboards/split70/ez/matrix.c ****             case 8:
 357:keyboards/split70/ez/matrix.c ****                 DDRB  |= (1<<2);
 358:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<2);
 359:keyboards/split70/ez/matrix.c ****                 break;
 360:keyboards/split70/ez/matrix.c ****             case 9:
 361:keyboards/split70/ez/matrix.c ****                 DDRB  |= (1<<3);
 362:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<3);
 363:keyboards/split70/ez/matrix.c ****                 break;
 364:keyboards/split70/ez/matrix.c ****             case 10:
 365:keyboards/split70/ez/matrix.c ****                 DDRD  |= (1<<2);
 366:keyboards/split70/ez/matrix.c ****                 PORTD &= ~(1<<3);
 367:keyboards/split70/ez/matrix.c ****                 break;
 368:keyboards/split70/ez/matrix.c ****             case 11:
 369:keyboards/split70/ez/matrix.c ****                 DDRD  |= (1<<3);
 564               		.loc 1 369 0
 565 0150 539A      		sbi 0xa,3
 566 0152 00C0      		rjmp .L60
 567               	.L31:
 353:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<1);
 568               		.loc 1 353 0
 569 0154 219A      		sbi 0x4,1
 354:keyboards/split70/ez/matrix.c ****                 break;
 570               		.loc 1 354 0
 571 0156 2998      		cbi 0x5,1
 572 0158 00C0      		rjmp .L24
 573               	.L32:
 357:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<2);
 574               		.loc 1 357 0
 575 015a 229A      		sbi 0x4,2
 358:keyboards/split70/ez/matrix.c ****                 break;
 576               		.loc 1 358 0
 577 015c 2A98      		cbi 0x5,2
 578 015e 00C0      		rjmp .L24
 579               	.L29:
 361:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<3);
 580               		.loc 1 361 0
 581 0160 239A      		sbi 0x4,3
 362:keyboards/split70/ez/matrix.c ****                 break;
 582               		.loc 1 362 0
 583 0162 2B98      		cbi 0x5,3
 584 0164 00C0      		rjmp .L24
 585               	.L33:
 365:keyboards/split70/ez/matrix.c ****                 PORTD &= ~(1<<3);
 586               		.loc 1 365 0
 587 0166 529A      		sbi 0xa,2
 588               	.L60:
 370:keyboards/split70/ez/matrix.c ****                 PORTD &= ~(1<<3);
 589               		.loc 1 370 0
 590 0168 5B98      		cbi 0xb,3
 591 016a 00C0      		rjmp .L24
 592               	.LVL40:
 593               	.L35:
 594               	.LBE28:
 595               	.LBE36:
 596               	.LBB37:
 597               	.LBB35:
 284:keyboards/split70/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 598               		.loc 1 284 0
 599 016c CFB1      		in r28,0xf
 600 016e C095      		com r28
 601 0170 C170      		andi r28,lo8(1)
 602 0172 799B      		sbis 0xf,1
 603 0174 00C0      		rjmp .L53
 604 0176 80E0      		ldi r24,0
 605               	.L40:
 606 0178 C82B      		or r28,r24
 285:keyboards/split70/ez/matrix.c ****             (PINF&(1<<4) ? 0 : (1<<2)) |
 607               		.loc 1 285 0
 608 017a 7C9B      		sbis 0xf,4
 609 017c 00C0      		rjmp .L54
 610 017e 80E0      		ldi r24,0
 611               	.L41:
 612 0180 C82B      		or r28,r24
 286:keyboards/split70/ez/matrix.c ****             (PINF&(1<<5) ? 0 : (1<<3)) |
 613               		.loc 1 286 0
 614 0182 7D9B      		sbis 0xf,5
 615 0184 00C0      		rjmp .L55
 616 0186 80E0      		ldi r24,0
 617               	.L42:
 618 0188 C82B      		or r28,r24
 287:keyboards/split70/ez/matrix.c ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 619               		.loc 1 287 0
 620 018a 7E9B      		sbis 0xf,6
 621 018c 00C0      		rjmp .L56
 622 018e 80E0      		ldi r24,0
 623               	.L43:
 624 0190 C82B      		or r28,r24
 289:keyboards/split70/ez/matrix.c ****     }
 625               		.loc 1 289 0
 626 0192 8FB1      		in r24,0xf
 288:keyboards/split70/ez/matrix.c ****             (PINF&(1<<7) ? 0 : (1<<5)) ;
 627               		.loc 1 288 0
 628 0194 8095      		com r24
 629 0196 881F      		rol r24
 630 0198 8827      		clr r24
 631 019a 881F      		rol r24
 632 019c 8295      		swap r24
 633 019e 880F      		lsl r24
 634 01a0 807E      		andi r24,lo8(-32)
 635 01a2 C82B      		or r28,r24
 636 01a4 00C0      		rjmp .L36
 637               	.L53:
 284:keyboards/split70/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 638               		.loc 1 284 0
 639 01a6 82E0      		ldi r24,lo8(2)
 640 01a8 00C0      		rjmp .L40
 641               	.L54:
 285:keyboards/split70/ez/matrix.c ****             (PINF&(1<<4) ? 0 : (1<<2)) |
 642               		.loc 1 285 0
 643 01aa 84E0      		ldi r24,lo8(4)
 644 01ac 00C0      		rjmp .L41
 645               	.L55:
 286:keyboards/split70/ez/matrix.c ****             (PINF&(1<<5) ? 0 : (1<<3)) |
 646               		.loc 1 286 0
 647 01ae 88E0      		ldi r24,lo8(8)
 648 01b0 00C0      		rjmp .L42
 649               	.L56:
 287:keyboards/split70/ez/matrix.c ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 650               		.loc 1 287 0
 651 01b2 80E1      		ldi r24,lo8(16)
 652 01b4 00C0      		rjmp .L43
 653               	.L52:
 269:keyboards/split70/ez/matrix.c ****         } else {
 654               		.loc 1 269 0
 655 01b6 C0E0      		ldi r28,0
 656 01b8 00C0      		rjmp .L36
 657               	.LVL41:
 658               	.L49:
 659 01ba E0E0      		ldi r30,lo8(matrix)
 660 01bc F0E0      		ldi r31,hi8(matrix)
 661               	.L50:
 662               	.LVL42:
 663               	.LBE35:
 664               	.LBE37:
 665               	.LBE38:
 666               	.LBE41:
 667               	.LBB42:
 197:keyboards/split70/ez/matrix.c ****             }
 668               		.loc 1 197 0 discriminator 3
 669 01be D601      		movw r26,r12
 670 01c0 8D91      		ld r24,X+
 671 01c2 6D01      		movw r12,r26
 672               	.LVL43:
 673 01c4 8193      		st Z+,r24
 674               	.LVL44:
 196:keyboards/split70/ez/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 675               		.loc 1 196 0 discriminator 3
 676 01c6 B0E0      		ldi r27,lo8(matrix_debouncing+12)
 677 01c8 CB16      		cp r12,r27
 678 01ca B0E0      		ldi r27,hi8(matrix_debouncing+12)
 679 01cc DB06      		cpc r13,r27
 680 01ce 01F4      		brne .L50
 681 01d0 00C0      		rjmp .L48
 682               	.LBE42:
 683               		.cfi_endproc
 684               	.LFE115:
 686               		.section	.text.matrix_is_modified,"ax",@progbits
 687               	.global	matrix_is_modified
 689               	matrix_is_modified:
 690               	.LFB116:
 208:keyboards/split70/ez/matrix.c ****     if (debouncing) return false;
 691               		.loc 1 208 0
 692               		.cfi_startproc
 693               	/* prologue: function */
 694               	/* frame size = 0 */
 695               	/* stack size = 0 */
 696               	.L__stack_usage = 0
 209:keyboards/split70/ez/matrix.c ****     return true;
 697               		.loc 1 209 0
 698 0000 81E0      		ldi r24,lo8(1)
 699 0002 9091 0000 		lds r25,debouncing
 700 0006 9111      		cpse r25,__zero_reg__
 701 0008 80E0      		ldi r24,0
 702               	.L62:
 211:keyboards/split70/ez/matrix.c **** 
 703               		.loc 1 211 0
 704 000a 0895      		ret
 705               		.cfi_endproc
 706               	.LFE116:
 708               		.section	.text.matrix_is_on,"ax",@progbits
 709               	.global	matrix_is_on
 711               	matrix_is_on:
 712               	.LFB117:
 215:keyboards/split70/ez/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 713               		.loc 1 215 0
 714               		.cfi_startproc
 715               	.LVL45:
 716               	/* prologue: function */
 717               	/* frame size = 0 */
 718               	/* stack size = 0 */
 719               	.L__stack_usage = 0
 216:keyboards/split70/ez/matrix.c **** }
 720               		.loc 1 216 0
 721 0000 E82F      		mov r30,r24
 722 0002 F0E0      		ldi r31,0
 723 0004 E050      		subi r30,lo8(-(matrix))
 724 0006 F040      		sbci r31,hi8(-(matrix))
 725 0008 2081      		ld r18,Z
 726 000a 30E0      		ldi r19,0
 727 000c 81E0      		ldi r24,lo8(1)
 728 000e 90E0      		ldi r25,0
 729               	.LVL46:
 730 0010 00C0      		rjmp 2f
 731               		1:
 732 0012 880F      		lsl r24
 733 0014 991F      		rol r25
 734               		2:
 735 0016 6A95      		dec r22
 736 0018 02F4      		brpl 1b
 737 001a 2823      		and r18,r24
 738 001c 3923      		and r19,r25
 739 001e 81E0      		ldi r24,lo8(1)
 740 0020 232B      		or r18,r19
 741 0022 01F4      		brne .L67
 742 0024 80E0      		ldi r24,0
 743               	.L67:
 217:keyboards/split70/ez/matrix.c **** 
 744               		.loc 1 217 0
 745 0026 0895      		ret
 746               		.cfi_endproc
 747               	.LFE117:
 749               		.section	.text.matrix_get_row,"ax",@progbits
 750               	.global	matrix_get_row
 752               	matrix_get_row:
 753               	.LFB118:
 221:keyboards/split70/ez/matrix.c ****     return matrix[row];
 754               		.loc 1 221 0
 755               		.cfi_startproc
 756               	.LVL47:
 757               	/* prologue: function */
 758               	/* frame size = 0 */
 759               	/* stack size = 0 */
 760               	.L__stack_usage = 0
 222:keyboards/split70/ez/matrix.c **** }
 761               		.loc 1 222 0
 762 0000 E82F      		mov r30,r24
 763 0002 F0E0      		ldi r31,0
 764 0004 E050      		subi r30,lo8(-(matrix))
 765 0006 F040      		sbci r31,hi8(-(matrix))
 223:keyboards/split70/ez/matrix.c **** 
 766               		.loc 1 223 0
 767 0008 8081      		ld r24,Z
 768               	.LVL48:
 769 000a 0895      		ret
 770               		.cfi_endproc
 771               	.LFE118:
 773               		.section	.text.matrix_print,"ax",@progbits
 774               	.global	matrix_print
 776               	matrix_print:
 777               	.LFB119:
 226:keyboards/split70/ez/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 778               		.loc 1 226 0
 779               		.cfi_startproc
 780               	/* prologue: function */
 781               	/* frame size = 0 */
 782               	/* stack size = 0 */
 783               	.L__stack_usage = 0
 784               	.LVL49:
 785 0000 0895      		ret
 786               		.cfi_endproc
 787               	.LFE119:
 789               		.section	.text.matrix_key_count,"ax",@progbits
 790               	.global	matrix_key_count
 792               	matrix_key_count:
 793               	.LFB120:
 236:keyboards/split70/ez/matrix.c ****     uint8_t count = 0;
 794               		.loc 1 236 0
 795               		.cfi_startproc
 236:keyboards/split70/ez/matrix.c ****     uint8_t count = 0;
 796               		.loc 1 236 0
 797 0000 0F93      		push r16
 798               	.LCFI10:
 799               		.cfi_def_cfa_offset 3
 800               		.cfi_offset 16, -2
 801 0002 1F93      		push r17
 802               	.LCFI11:
 803               		.cfi_def_cfa_offset 4
 804               		.cfi_offset 17, -3
 805 0004 CF93      		push r28
 806               	.LCFI12:
 807               		.cfi_def_cfa_offset 5
 808               		.cfi_offset 28, -4
 809               	/* prologue: function */
 810               	/* frame size = 0 */
 811               	/* stack size = 3 */
 812               	.L__stack_usage = 3
 813               	.LVL50:
 814 0006 00E0      		ldi r16,lo8(matrix)
 815 0008 10E0      		ldi r17,hi8(matrix)
 237:keyboards/split70/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 816               		.loc 1 237 0
 817 000a C0E0      		ldi r28,0
 818               	.LVL51:
 819               	.L71:
 820               	.LBB43:
 239:keyboards/split70/ez/matrix.c ****     }
 821               		.loc 1 239 0 discriminator 3
 822 000c F801      		movw r30,r16
 823 000e 8191      		ld r24,Z+
 824 0010 8F01      		movw r16,r30
 825               	.LVL52:
 826 0012 90E0      		ldi r25,0
 827 0014 0E94 0000 		call bitpop16
 828               	.LVL53:
 829 0018 C80F      		add r28,r24
 830               	.LVL54:
 238:keyboards/split70/ez/matrix.c ****         count += bitpop16(matrix[i]);
 831               		.loc 1 238 0 discriminator 3
 832 001a F0E0      		ldi r31,hi8(matrix+12)
 833 001c 0030      		cpi r16,lo8(matrix+12)
 834 001e 1F07      		cpc r17,r31
 835 0020 01F4      		brne .L71
 836               	.LBE43:
 242:keyboards/split70/ez/matrix.c **** 
 837               		.loc 1 242 0
 838 0022 8C2F      		mov r24,r28
 839               	/* epilogue start */
 840 0024 CF91      		pop r28
 841               	.LVL55:
 842 0026 1F91      		pop r17
 843 0028 0F91      		pop r16
 844               	.LVL56:
 845 002a 0895      		ret
 846               		.cfi_endproc
 847               	.LFE120:
 849               		.section	.bss.mcp23018_reset_loop,"aw",@nobits
 852               	mcp23018_reset_loop:
 853 0000 00        		.zero	1
 854               		.section	.bss.matrix_debouncing,"aw",@nobits
 857               	matrix_debouncing:
 858 0000 0000 0000 		.zero	12
 858      0000 0000 
 858      0000 0000 
 859               		.section	.bss.matrix,"aw",@nobits
 862               	matrix:
 863 0000 0000 0000 		.zero	12
 863      0000 0000 
 863      0000 0000 
 864               		.section	.data.debouncing,"aw",@progbits
 867               	debouncing:
 868 0000 05        		.byte	5
 869               		.text
 870               	.Letext0:
 871               		.file 3 "/usr/avr/include/stdint.h"
 872               		.file 4 "/usr/lib/gcc/avr/6.3.0/include/stddef.h"
 873               		.file 5 "./tmk_core/common/action_layer.h"
 874               		.file 6 "./tmk_core/common/debug.h"
 875               		.file 7 "./tmk_core/common/matrix.h"
 876               		.file 8 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 877               		.file 9 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 878               		.file 10 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
 879               		.file 11 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/HostStandardReq.h"
 880               		.file 12 "/usr/avr/include/stdio.h"
 881               		.file 13 "./tmk_core/common/report.h"
 882               		.file 14 "./tmk_core/common/host.h"
 883               		.file 15 "./quantum/keycode_config.h"
 884               		.file 16 "./quantum/keymap.h"
 885               		.file 17 "./tmk_core/common/timer.h"
 886               		.file 18 "./tmk_core/common/action_util.h"
 887               		.file 19 "/usr/avr/include/stdlib.h"
 888               		.file 20 "keyboards/split70/ez/ez.h"
 889               		.file 21 "./quantum/process_keycode/process_unicode_common.h"
 890               		.file 22 "keyboards/split70/ez/i2cmaster.h"
 891               		.file 23 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccvVLZtC.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccvVLZtC.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccvVLZtC.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccvVLZtC.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccvVLZtC.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccvVLZtC.s:12     .text.init_cols:0000000000000000 init_cols
     /tmp/ccvVLZtC.s:35     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccvVLZtC.s:94     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccvVLZtC.s:94     .text.matrix_scan_user:0000000000000000 matrix_scan_user.localalias.0
     /tmp/ccvVLZtC.s:110    .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccvVLZtC.s:124    .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccvVLZtC.s:141    .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccvVLZtC.s:158    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccvVLZtC.s:175    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccvVLZtC.s:192    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccvVLZtC.s:862    .bss.matrix:0000000000000000 matrix
     /tmp/ccvVLZtC.s:857    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccvVLZtC.s:238    .text.matrix_power_up:0000000000000000 matrix_power_up
     /tmp/ccvVLZtC.s:284    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccvVLZtC.s:852    .bss.mcp23018_reset_loop:0000000000000000 mcp23018_reset_loop
     /tmp/ccvVLZtC.s:867    .data.debouncing:0000000000000000 debouncing
     /tmp/ccvVLZtC.s:689    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccvVLZtC.s:711    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccvVLZtC.s:752    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccvVLZtC.s:776    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccvVLZtC.s:792    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
mcp23018_status
i2c_start
i2c_write
i2c_stop
init_mcp23018
matrix_init_quantum
i2c_readNak
matrix_scan_quantum
bitpop16
__do_copy_data
__do_clear_bss
