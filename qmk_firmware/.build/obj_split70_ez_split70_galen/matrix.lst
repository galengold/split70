   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.init_cols,"ax",@progbits
  12               	init_cols:
  13               	.LFB121:
  14               		.file 1 "keyboards/split70/ez/matrix.c"
   1:keyboards/split70/ez/matrix.c **** /*
   2:keyboards/split70/ez/matrix.c **** 
   3:keyboards/split70/ez/matrix.c **** Note for ErgoDox EZ customizers: Here be dragons!
   4:keyboards/split70/ez/matrix.c **** This is not a file you want to be messing with.
   5:keyboards/split70/ez/matrix.c **** All of the interesting stuff for you is under keymaps/ :)
   6:keyboards/split70/ez/matrix.c **** Love, Erez
   7:keyboards/split70/ez/matrix.c **** 
   8:keyboards/split70/ez/matrix.c **** Copyright 2013 Oleg Kostyuk <cub.uanic@gmail.com>
   9:keyboards/split70/ez/matrix.c **** 
  10:keyboards/split70/ez/matrix.c **** This program is free software: you can redistribute it and/or modify
  11:keyboards/split70/ez/matrix.c **** it under the terms of the GNU General Public License as published by
  12:keyboards/split70/ez/matrix.c **** the Free Software Foundation, either version 2 of the License, or
  13:keyboards/split70/ez/matrix.c **** (at your option) any later version.
  14:keyboards/split70/ez/matrix.c **** 
  15:keyboards/split70/ez/matrix.c **** This program is distributed in the hope that it will be useful,
  16:keyboards/split70/ez/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  17:keyboards/split70/ez/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  18:keyboards/split70/ez/matrix.c **** GNU General Public License for more details.
  19:keyboards/split70/ez/matrix.c **** 
  20:keyboards/split70/ez/matrix.c **** You should have received a copy of the GNU General Public License
  21:keyboards/split70/ez/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  22:keyboards/split70/ez/matrix.c **** */
  23:keyboards/split70/ez/matrix.c **** 
  24:keyboards/split70/ez/matrix.c **** /*
  25:keyboards/split70/ez/matrix.c ****  * scan matrix
  26:keyboards/split70/ez/matrix.c ****  */
  27:keyboards/split70/ez/matrix.c **** #include <stdint.h>
  28:keyboards/split70/ez/matrix.c **** #include <stdbool.h>
  29:keyboards/split70/ez/matrix.c **** #include <avr/io.h>
  30:keyboards/split70/ez/matrix.c **** #include "wait.h"
  31:keyboards/split70/ez/matrix.c **** #include "action_layer.h"
  32:keyboards/split70/ez/matrix.c **** #include "print.h"
  33:keyboards/split70/ez/matrix.c **** #include "debug.h"
  34:keyboards/split70/ez/matrix.c **** #include "util.h"
  35:keyboards/split70/ez/matrix.c **** #include "matrix.h"
  36:keyboards/split70/ez/matrix.c **** #include "ez.h"
  37:keyboards/split70/ez/matrix.c **** #include "i2cmaster.h"
  38:keyboards/split70/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
  39:keyboards/split70/ez/matrix.c **** #include  "timer.h"
  40:keyboards/split70/ez/matrix.c **** #endif
  41:keyboards/split70/ez/matrix.c **** 
  42:keyboards/split70/ez/matrix.c **** /*
  43:keyboards/split70/ez/matrix.c ****  * This constant define not debouncing time in msecs, but amount of matrix
  44:keyboards/split70/ez/matrix.c ****  * scan loops which should be made to get stable debounced results.
  45:keyboards/split70/ez/matrix.c ****  *
  46:keyboards/split70/ez/matrix.c ****  * On Ergodox matrix scan rate is relatively low, because of slow I2C.
  47:keyboards/split70/ez/matrix.c ****  * Now it's only 317 scans/second, or about 3.15 msec/scan.
  48:keyboards/split70/ez/matrix.c ****  * According to Cherry specs, debouncing time is 5 msec.
  49:keyboards/split70/ez/matrix.c ****  *
  50:keyboards/split70/ez/matrix.c ****  * And so, there is no sense to have DEBOUNCE higher than 2.
  51:keyboards/split70/ez/matrix.c ****  */
  52:keyboards/split70/ez/matrix.c **** 
  53:keyboards/split70/ez/matrix.c **** #ifndef DEBOUNCE
  54:keyboards/split70/ez/matrix.c **** #   define DEBOUNCE	5
  55:keyboards/split70/ez/matrix.c **** #endif
  56:keyboards/split70/ez/matrix.c **** static uint8_t debouncing = DEBOUNCE;
  57:keyboards/split70/ez/matrix.c **** 
  58:keyboards/split70/ez/matrix.c **** /* matrix state(1:on, 0:off) */
  59:keyboards/split70/ez/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  60:keyboards/split70/ez/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  61:keyboards/split70/ez/matrix.c **** 
  62:keyboards/split70/ez/matrix.c **** static matrix_row_t read_cols(uint8_t row);
  63:keyboards/split70/ez/matrix.c **** static void init_cols(void);
  64:keyboards/split70/ez/matrix.c **** static void unselect_rows(void);
  65:keyboards/split70/ez/matrix.c **** static void select_row(uint8_t row);
  66:keyboards/split70/ez/matrix.c **** 
  67:keyboards/split70/ez/matrix.c **** static uint8_t mcp23018_reset_loop;
  68:keyboards/split70/ez/matrix.c **** 
  69:keyboards/split70/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
  70:keyboards/split70/ez/matrix.c **** uint32_t matrix_timer;
  71:keyboards/split70/ez/matrix.c **** uint32_t matrix_scan_count;
  72:keyboards/split70/ez/matrix.c **** #endif
  73:keyboards/split70/ez/matrix.c **** 
  74:keyboards/split70/ez/matrix.c **** 
  75:keyboards/split70/ez/matrix.c **** __attribute__ ((weak))
  76:keyboards/split70/ez/matrix.c **** void matrix_init_user(void) {}
  77:keyboards/split70/ez/matrix.c **** 
  78:keyboards/split70/ez/matrix.c **** __attribute__ ((weak))
  79:keyboards/split70/ez/matrix.c **** void matrix_scan_user(void) {}
  80:keyboards/split70/ez/matrix.c **** 
  81:keyboards/split70/ez/matrix.c **** __attribute__ ((weak))
  82:keyboards/split70/ez/matrix.c **** void matrix_init_kb(void) {
  83:keyboards/split70/ez/matrix.c ****   matrix_init_user();
  84:keyboards/split70/ez/matrix.c **** }
  85:keyboards/split70/ez/matrix.c **** 
  86:keyboards/split70/ez/matrix.c **** __attribute__ ((weak))
  87:keyboards/split70/ez/matrix.c **** void matrix_scan_kb(void) {
  88:keyboards/split70/ez/matrix.c ****   matrix_scan_user();
  89:keyboards/split70/ez/matrix.c **** }
  90:keyboards/split70/ez/matrix.c **** 
  91:keyboards/split70/ez/matrix.c **** inline
  92:keyboards/split70/ez/matrix.c **** uint8_t matrix_rows(void)
  93:keyboards/split70/ez/matrix.c **** {
  94:keyboards/split70/ez/matrix.c ****     return MATRIX_ROWS;
  95:keyboards/split70/ez/matrix.c **** }
  96:keyboards/split70/ez/matrix.c **** 
  97:keyboards/split70/ez/matrix.c **** inline
  98:keyboards/split70/ez/matrix.c **** uint8_t matrix_cols(void)
  99:keyboards/split70/ez/matrix.c **** {
 100:keyboards/split70/ez/matrix.c ****     return MATRIX_COLS;
 101:keyboards/split70/ez/matrix.c **** }
 102:keyboards/split70/ez/matrix.c **** 
 103:keyboards/split70/ez/matrix.c **** void matrix_init(void)
 104:keyboards/split70/ez/matrix.c **** {
 105:keyboards/split70/ez/matrix.c ****     // initialize row and col
 106:keyboards/split70/ez/matrix.c **** 
 107:keyboards/split70/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 108:keyboards/split70/ez/matrix.c **** 
 109:keyboards/split70/ez/matrix.c **** 
 110:keyboards/split70/ez/matrix.c ****     unselect_rows();
 111:keyboards/split70/ez/matrix.c ****     init_cols();
 112:keyboards/split70/ez/matrix.c **** 
 113:keyboards/split70/ez/matrix.c ****     // initialize matrix state: all keys off
 114:keyboards/split70/ez/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 115:keyboards/split70/ez/matrix.c ****         matrix[i] = 0;
 116:keyboards/split70/ez/matrix.c ****         matrix_debouncing[i] = 0;
 117:keyboards/split70/ez/matrix.c ****     }
 118:keyboards/split70/ez/matrix.c **** 
 119:keyboards/split70/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 120:keyboards/split70/ez/matrix.c ****     matrix_timer = timer_read32();
 121:keyboards/split70/ez/matrix.c ****     matrix_scan_count = 0;
 122:keyboards/split70/ez/matrix.c **** #endif
 123:keyboards/split70/ez/matrix.c **** 
 124:keyboards/split70/ez/matrix.c ****     matrix_init_quantum();
 125:keyboards/split70/ez/matrix.c **** 
 126:keyboards/split70/ez/matrix.c **** }
 127:keyboards/split70/ez/matrix.c **** 
 128:keyboards/split70/ez/matrix.c **** void matrix_power_up(void) {
 129:keyboards/split70/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 130:keyboards/split70/ez/matrix.c **** 
 131:keyboards/split70/ez/matrix.c ****     unselect_rows();
 132:keyboards/split70/ez/matrix.c ****     init_cols();
 133:keyboards/split70/ez/matrix.c **** 
 134:keyboards/split70/ez/matrix.c ****     // initialize matrix state: all keys off
 135:keyboards/split70/ez/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 136:keyboards/split70/ez/matrix.c ****         matrix[i] = 0;
 137:keyboards/split70/ez/matrix.c ****         matrix_debouncing[i] = 0;
 138:keyboards/split70/ez/matrix.c ****     }
 139:keyboards/split70/ez/matrix.c **** 
 140:keyboards/split70/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 141:keyboards/split70/ez/matrix.c ****     matrix_timer = timer_read32();
 142:keyboards/split70/ez/matrix.c ****     matrix_scan_count = 0;
 143:keyboards/split70/ez/matrix.c **** #endif
 144:keyboards/split70/ez/matrix.c **** 
 145:keyboards/split70/ez/matrix.c **** }
 146:keyboards/split70/ez/matrix.c **** 
 147:keyboards/split70/ez/matrix.c **** uint8_t matrix_scan(void)
 148:keyboards/split70/ez/matrix.c **** {
 149:keyboards/split70/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 150:keyboards/split70/ez/matrix.c ****         if (++mcp23018_reset_loop == 0) {
 151:keyboards/split70/ez/matrix.c ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
 152:keyboards/split70/ez/matrix.c ****             // this will be approx bit more frequent than once per second
 153:keyboards/split70/ez/matrix.c ****             print("trying to reset mcp23018\n");
 154:keyboards/split70/ez/matrix.c ****             mcp23018_status = init_mcp23018();
 155:keyboards/split70/ez/matrix.c ****             if (mcp23018_status) {
 156:keyboards/split70/ez/matrix.c ****                 print("left side not responding\n");
 157:keyboards/split70/ez/matrix.c ****             } else {
 158:keyboards/split70/ez/matrix.c ****                 print("left side attached\n");
 159:keyboards/split70/ez/matrix.c ****             }
 160:keyboards/split70/ez/matrix.c ****         }
 161:keyboards/split70/ez/matrix.c ****     }
 162:keyboards/split70/ez/matrix.c **** 
 163:keyboards/split70/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 164:keyboards/split70/ez/matrix.c ****     matrix_scan_count++;
 165:keyboards/split70/ez/matrix.c **** 
 166:keyboards/split70/ez/matrix.c ****     uint32_t timer_now = timer_read32();
 167:keyboards/split70/ez/matrix.c ****     if (TIMER_DIFF_32(timer_now, matrix_timer)>1000) {
 168:keyboards/split70/ez/matrix.c ****         print("matrix scan frequency: ");
 169:keyboards/split70/ez/matrix.c ****         pdec(matrix_scan_count);
 170:keyboards/split70/ez/matrix.c ****         print("\n");
 171:keyboards/split70/ez/matrix.c **** 
 172:keyboards/split70/ez/matrix.c ****         matrix_timer = timer_now;
 173:keyboards/split70/ez/matrix.c ****         matrix_scan_count = 0;
 174:keyboards/split70/ez/matrix.c ****     }
 175:keyboards/split70/ez/matrix.c **** #endif
 176:keyboards/split70/ez/matrix.c **** 
 177:keyboards/split70/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 178:keyboards/split70/ez/matrix.c ****         select_row(i);
 179:keyboards/split70/ez/matrix.c ****         wait_us(30);  // without this wait read unstable value.
 180:keyboards/split70/ez/matrix.c ****         matrix_row_t cols = read_cols(i);
 181:keyboards/split70/ez/matrix.c ****         if (matrix_debouncing[i] != cols) {
 182:keyboards/split70/ez/matrix.c ****             matrix_debouncing[i] = cols;
 183:keyboards/split70/ez/matrix.c ****             if (debouncing) {
 184:keyboards/split70/ez/matrix.c ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 185:keyboards/split70/ez/matrix.c ****             }
 186:keyboards/split70/ez/matrix.c ****             debouncing = DEBOUNCE;
 187:keyboards/split70/ez/matrix.c ****         }
 188:keyboards/split70/ez/matrix.c ****         unselect_rows();
 189:keyboards/split70/ez/matrix.c ****     }
 190:keyboards/split70/ez/matrix.c **** 
 191:keyboards/split70/ez/matrix.c ****     if (debouncing) {
 192:keyboards/split70/ez/matrix.c ****         if (--debouncing) {
 193:keyboards/split70/ez/matrix.c ****             wait_us(1);
 194:keyboards/split70/ez/matrix.c ****             // this should be wait_ms(1) but has been left as-is at EZ's request
 195:keyboards/split70/ez/matrix.c ****         } else {
 196:keyboards/split70/ez/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 197:keyboards/split70/ez/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 198:keyboards/split70/ez/matrix.c ****             }
 199:keyboards/split70/ez/matrix.c ****         }
 200:keyboards/split70/ez/matrix.c ****     }
 201:keyboards/split70/ez/matrix.c **** 
 202:keyboards/split70/ez/matrix.c ****     matrix_scan_quantum();
 203:keyboards/split70/ez/matrix.c **** 
 204:keyboards/split70/ez/matrix.c ****     return 1;
 205:keyboards/split70/ez/matrix.c **** }
 206:keyboards/split70/ez/matrix.c **** 
 207:keyboards/split70/ez/matrix.c **** bool matrix_is_modified(void)
 208:keyboards/split70/ez/matrix.c **** {
 209:keyboards/split70/ez/matrix.c ****     if (debouncing) return false;
 210:keyboards/split70/ez/matrix.c ****     return true;
 211:keyboards/split70/ez/matrix.c **** }
 212:keyboards/split70/ez/matrix.c **** 
 213:keyboards/split70/ez/matrix.c **** inline
 214:keyboards/split70/ez/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 215:keyboards/split70/ez/matrix.c **** {
 216:keyboards/split70/ez/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 217:keyboards/split70/ez/matrix.c **** }
 218:keyboards/split70/ez/matrix.c **** 
 219:keyboards/split70/ez/matrix.c **** inline
 220:keyboards/split70/ez/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 221:keyboards/split70/ez/matrix.c **** {
 222:keyboards/split70/ez/matrix.c ****     return matrix[row];
 223:keyboards/split70/ez/matrix.c **** }
 224:keyboards/split70/ez/matrix.c **** 
 225:keyboards/split70/ez/matrix.c **** void matrix_print(void)
 226:keyboards/split70/ez/matrix.c **** {
 227:keyboards/split70/ez/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 228:keyboards/split70/ez/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 229:keyboards/split70/ez/matrix.c ****         phex(row); print(": ");
 230:keyboards/split70/ez/matrix.c ****         pbin_reverse16(matrix_get_row(row));
 231:keyboards/split70/ez/matrix.c ****         print("\n");
 232:keyboards/split70/ez/matrix.c ****     }
 233:keyboards/split70/ez/matrix.c **** }
 234:keyboards/split70/ez/matrix.c **** 
 235:keyboards/split70/ez/matrix.c **** uint8_t matrix_key_count(void)
 236:keyboards/split70/ez/matrix.c **** {
 237:keyboards/split70/ez/matrix.c ****     uint8_t count = 0;
 238:keyboards/split70/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 239:keyboards/split70/ez/matrix.c ****         count += bitpop16(matrix[i]);
 240:keyboards/split70/ez/matrix.c ****     }
 241:keyboards/split70/ez/matrix.c ****     return count;
 242:keyboards/split70/ez/matrix.c **** }
 243:keyboards/split70/ez/matrix.c **** 
 244:keyboards/split70/ez/matrix.c **** /* Column pin configuration
 245:keyboards/split70/ez/matrix.c ****  *
 246:keyboards/split70/ez/matrix.c ****  * Teensy
 247:keyboards/split70/ez/matrix.c ****  * col: 0   1   2   3   4   5
 248:keyboards/split70/ez/matrix.c ****  * pin: F7  F6  F5  F4  F1  F0
 249:keyboards/split70/ez/matrix.c ****  *
 250:keyboards/split70/ez/matrix.c ****  * MCP23018
 251:keyboards/split70/ez/matrix.c ****  * col: 0   1   2   3   4   5
 252:keyboards/split70/ez/matrix.c ****  * pin: B5  B4  B3  B2  B1  B0
 253:keyboards/split70/ez/matrix.c ****  */
 254:keyboards/split70/ez/matrix.c **** static void  init_cols(void)
 255:keyboards/split70/ez/matrix.c **** {
  15               		.loc 1 255 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 256:keyboards/split70/ez/matrix.c ****     // init on mcp23018
 257:keyboards/split70/ez/matrix.c ****     // not needed, already done as part of init_mcp23018()
 258:keyboards/split70/ez/matrix.c **** 
 259:keyboards/split70/ez/matrix.c ****     // init on teensy
 260:keyboards/split70/ez/matrix.c ****     // Input with pull-up(DDR:0, PORT:1)
 261:keyboards/split70/ez/matrix.c ****     DDRF  &= ~0xF3;
  21               		.loc 1 261 0
  22 0000 80B3      		in r24,0x10
  23 0002 8C70      		andi r24,lo8(12)
  24 0004 80BB      		out 0x10,r24
 262:keyboards/split70/ez/matrix.c ****     PORTF |=  0xF3;
  25               		.loc 1 262 0
  26 0006 81B3      		in r24,0x11
  27 0008 836F      		ori r24,lo8(-13)
  28 000a 81BB      		out 0x11,r24
  29               	/* epilogue start */
 263:keyboards/split70/ez/matrix.c **** }
  30               		.loc 1 263 0
  31 000c 0895      		ret
  32               		.cfi_endproc
  33               	.LFE121:
  35               		.section	.text.unselect_rows,"ax",@progbits
  37               	unselect_rows:
  38               	.LFB123:
 264:keyboards/split70/ez/matrix.c **** 
 265:keyboards/split70/ez/matrix.c **** static matrix_row_t read_cols(uint8_t row)
 266:keyboards/split70/ez/matrix.c **** {
 267:keyboards/split70/ez/matrix.c ****     if (row < 7) {
 268:keyboards/split70/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 269:keyboards/split70/ez/matrix.c ****             return 0;
 270:keyboards/split70/ez/matrix.c ****         } else {
 271:keyboards/split70/ez/matrix.c ****             uint8_t data = 0;
 272:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 273:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 274:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 275:keyboards/split70/ez/matrix.c ****             data = i2c_readNak();
 276:keyboards/split70/ez/matrix.c ****             data = ~data;
 277:keyboards/split70/ez/matrix.c ****         out:
 278:keyboards/split70/ez/matrix.c ****             i2c_stop();
 279:keyboards/split70/ez/matrix.c ****             return data;
 280:keyboards/split70/ez/matrix.c ****         }
 281:keyboards/split70/ez/matrix.c ****     } else {
 282:keyboards/split70/ez/matrix.c ****         // read from teensy
 283:keyboards/split70/ez/matrix.c ****         return
 284:keyboards/split70/ez/matrix.c ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 285:keyboards/split70/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 286:keyboards/split70/ez/matrix.c ****             (PINF&(1<<4) ? 0 : (1<<2)) |
 287:keyboards/split70/ez/matrix.c ****             (PINF&(1<<5) ? 0 : (1<<3)) |
 288:keyboards/split70/ez/matrix.c ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 289:keyboards/split70/ez/matrix.c ****             (PINF&(1<<7) ? 0 : (1<<5)) ;
 290:keyboards/split70/ez/matrix.c ****     }
 291:keyboards/split70/ez/matrix.c **** }
 292:keyboards/split70/ez/matrix.c **** 
 293:keyboards/split70/ez/matrix.c **** /* Row pin configuration
 294:keyboards/split70/ez/matrix.c ****  *
 295:keyboards/split70/ez/matrix.c ****  * Teensy
 296:keyboards/split70/ez/matrix.c ****  * row: 6   7   8   9   10  11
 297:keyboards/split70/ez/matrix.c ****  * pin: B0  B1  B2  B3  D2  D3
 298:keyboards/split70/ez/matrix.c ****  *
 299:keyboards/split70/ez/matrix.c ****  * MCP23018
 300:keyboards/split70/ez/matrix.c ****  * row: 0   1   2   3   4   5
 301:keyboards/split70/ez/matrix.c ****  * pin: A0  A1  A2  A3  A4  A5
 302:keyboards/split70/ez/matrix.c ****  */
 303:keyboards/split70/ez/matrix.c **** static void unselect_rows(void)
 304:keyboards/split70/ez/matrix.c **** {
  39               		.loc 1 304 0
  40               		.cfi_startproc
  41               	/* prologue: function */
  42               	/* frame size = 0 */
  43               	/* stack size = 0 */
  44               	.L__stack_usage = 0
 305:keyboards/split70/ez/matrix.c ****     // unselect on mcp23018
 306:keyboards/split70/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
  45               		.loc 1 306 0
  46 0000 8091 0000 		lds r24,mcp23018_status
  47 0004 8111      		cpse r24,__zero_reg__
  48 0006 00C0      		rjmp .L3
 307:keyboards/split70/ez/matrix.c ****         // do nothing
 308:keyboards/split70/ez/matrix.c ****     } else {
 309:keyboards/split70/ez/matrix.c ****         // set all rows hi-Z : 1
 310:keyboards/split70/ez/matrix.c ****         mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
  49               		.loc 1 310 0
  50 0008 80E4      		ldi r24,lo8(64)
  51 000a 0E94 0000 		call i2c_start
  52               	.LVL0:
  53 000e 8093 0000 		sts mcp23018_status,r24
  54 0012 8111      		cpse r24,__zero_reg__
  55 0014 00C0      		rjmp .L5
 311:keyboards/split70/ez/matrix.c ****         mcp23018_status = i2c_write(GPIOA);             if (mcp23018_status) goto out;
  56               		.loc 1 311 0
  57 0016 82E1      		ldi r24,lo8(18)
  58 0018 0E94 0000 		call i2c_write
  59               	.LVL1:
  60 001c 8093 0000 		sts mcp23018_status,r24
  61 0020 8111      		cpse r24,__zero_reg__
  62 0022 00C0      		rjmp .L5
 312:keyboards/split70/ez/matrix.c ****         mcp23018_status = i2c_write( 0xFF
  63               		.loc 1 312 0
  64 0024 8FEF      		ldi r24,lo8(-1)
  65 0026 0E94 0000 		call i2c_write
  66               	.LVL2:
  67 002a 8093 0000 		sts mcp23018_status,r24
  68               	.L5:
 313:keyboards/split70/ez/matrix.c ****                               & ~(0<<7)
 314:keyboards/split70/ez/matrix.c ****                           );                            if (mcp23018_status) goto out;
 315:keyboards/split70/ez/matrix.c ****     out:
 316:keyboards/split70/ez/matrix.c ****         i2c_stop();
  69               		.loc 1 316 0
  70 002e 0E94 0000 		call i2c_stop
  71               	.LVL3:
  72               	.L3:
 317:keyboards/split70/ez/matrix.c ****     }
 318:keyboards/split70/ez/matrix.c **** 
 319:keyboards/split70/ez/matrix.c ****     // unselect on teensy
 320:keyboards/split70/ez/matrix.c ****     // Hi-Z(DDR:0, PORT:0) to unselect
 321:keyboards/split70/ez/matrix.c ****     DDRB  &= ~0x0F;
  73               		.loc 1 321 0
  74 0032 84B1      		in r24,0x4
  75 0034 807F      		andi r24,lo8(-16)
  76 0036 84B9      		out 0x4,r24
 322:keyboards/split70/ez/matrix.c ****     PORTB &= ~0x0F;
  77               		.loc 1 322 0
  78 0038 85B1      		in r24,0x5
  79 003a 807F      		andi r24,lo8(-16)
  80 003c 85B9      		out 0x5,r24
 323:keyboards/split70/ez/matrix.c ****     DDRD  &= ~0x0C;
  81               		.loc 1 323 0
  82 003e 8AB1      		in r24,0xa
  83 0040 837F      		andi r24,lo8(-13)
  84 0042 8AB9      		out 0xa,r24
 324:keyboards/split70/ez/matrix.c ****     PORTD &= ~0x0C;
  85               		.loc 1 324 0
  86 0044 8BB1      		in r24,0xb
  87 0046 837F      		andi r24,lo8(-13)
  88 0048 8BB9      		out 0xb,r24
  89               	/* epilogue start */
 325:keyboards/split70/ez/matrix.c **** }
  90               		.loc 1 325 0
  91 004a 0895      		ret
  92               		.cfi_endproc
  93               	.LFE123:
  95               		.section	.text.matrix_init_user,"ax",@progbits
  96               		.weak	matrix_init_user
  98               	matrix_init_user:
  99               	.LFB107:
  76:keyboards/split70/ez/matrix.c **** 
 100               		.loc 1 76 0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
 106               	/* epilogue start */
  76:keyboards/split70/ez/matrix.c **** 
 107               		.loc 1 76 0
 108 0000 0895      		ret
 109               		.cfi_endproc
 110               	.LFE107:
 112               		.set	matrix_init_user.localalias.0,matrix_init_user
 113               		.section	.text.matrix_scan_user,"ax",@progbits
 114               		.weak	matrix_scan_user
 116               	matrix_scan_user:
 117               	.LFB126:
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 123               	/* epilogue start */
 124 0000 0895      		ret
 125               		.cfi_endproc
 126               	.LFE126:
 128               		.section	.text.matrix_init_kb,"ax",@progbits
 129               		.weak	matrix_init_kb
 131               	matrix_init_kb:
 132               	.LFB109:
  82:keyboards/split70/ez/matrix.c ****   matrix_init_user();
 133               		.loc 1 82 0
 134               		.cfi_startproc
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  83:keyboards/split70/ez/matrix.c **** }
 139               		.loc 1 83 0
 140 0000 0C94 0000 		jmp matrix_init_user
 141               	.LVL4:
 142               		.cfi_endproc
 143               	.LFE109:
 145               		.section	.text.matrix_scan_kb,"ax",@progbits
 146               		.weak	matrix_scan_kb
 148               	matrix_scan_kb:
 149               	.LFB110:
  87:keyboards/split70/ez/matrix.c ****   matrix_scan_user();
 150               		.loc 1 87 0
 151               		.cfi_startproc
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
  88:keyboards/split70/ez/matrix.c **** }
 156               		.loc 1 88 0
 157 0000 0C94 0000 		jmp matrix_scan_user
 158               	.LVL5:
 159               		.cfi_endproc
 160               	.LFE110:
 162               		.section	.text.matrix_rows,"ax",@progbits
 163               	.global	matrix_rows
 165               	matrix_rows:
 166               	.LFB111:
  93:keyboards/split70/ez/matrix.c ****     return MATRIX_ROWS;
 167               		.loc 1 93 0
 168               		.cfi_startproc
 169               	/* prologue: function */
 170               	/* frame size = 0 */
 171               	/* stack size = 0 */
 172               	.L__stack_usage = 0
  95:keyboards/split70/ez/matrix.c **** 
 173               		.loc 1 95 0
 174 0000 8CE0      		ldi r24,lo8(12)
 175               	/* epilogue start */
 176 0002 0895      		ret
 177               		.cfi_endproc
 178               	.LFE111:
 180               		.section	.text.matrix_cols,"ax",@progbits
 181               	.global	matrix_cols
 183               	matrix_cols:
 184               	.LFB112:
  99:keyboards/split70/ez/matrix.c ****     return MATRIX_COLS;
 185               		.loc 1 99 0
 186               		.cfi_startproc
 187               	/* prologue: function */
 188               	/* frame size = 0 */
 189               	/* stack size = 0 */
 190               	.L__stack_usage = 0
 101:keyboards/split70/ez/matrix.c **** 
 191               		.loc 1 101 0
 192 0000 86E0      		ldi r24,lo8(6)
 193               	/* epilogue start */
 194 0002 0895      		ret
 195               		.cfi_endproc
 196               	.LFE112:
 198               		.section	.text.matrix_init,"ax",@progbits
 199               	.global	matrix_init
 201               	matrix_init:
 202               	.LFB113:
 104:keyboards/split70/ez/matrix.c ****     // initialize row and col
 203               		.loc 1 104 0
 204               		.cfi_startproc
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 107:keyboards/split70/ez/matrix.c **** 
 209               		.loc 1 107 0
 210 0000 0E94 0000 		call init_mcp23018
 211               	.LVL6:
 212 0004 8093 0000 		sts mcp23018_status,r24
 110:keyboards/split70/ez/matrix.c ****     init_cols();
 213               		.loc 1 110 0
 214 0008 0E94 0000 		call unselect_rows
 215               	.LVL7:
 111:keyboards/split70/ez/matrix.c **** 
 216               		.loc 1 111 0
 217 000c 0E94 0000 		call init_cols
 218               	.LVL8:
 219 0010 E0E0      		ldi r30,lo8(matrix)
 220 0012 F0E0      		ldi r31,hi8(matrix)
 221 0014 A0E0      		ldi r26,lo8(matrix_debouncing)
 222 0016 B0E0      		ldi r27,hi8(matrix_debouncing)
 223               	.LVL9:
 224               	.L14:
 225               	.LBB9:
 115:keyboards/split70/ez/matrix.c ****         matrix_debouncing[i] = 0;
 226               		.loc 1 115 0 discriminator 3
 227 0018 1192      		st Z+,__zero_reg__
 228               	.LVL10:
 116:keyboards/split70/ez/matrix.c ****     }
 229               		.loc 1 116 0 discriminator 3
 230 001a 1D92      		st X+,__zero_reg__
 231               	.LVL11:
 114:keyboards/split70/ez/matrix.c ****         matrix[i] = 0;
 232               		.loc 1 114 0 discriminator 3
 233 001c 80E0      		ldi r24,hi8(matrix+12)
 234 001e E030      		cpi r30,lo8(matrix+12)
 235 0020 F807      		cpc r31,r24
 236 0022 01F4      		brne .L14
 237               	.LBE9:
 124:keyboards/split70/ez/matrix.c **** 
 238               		.loc 1 124 0
 239 0024 0C94 0000 		jmp matrix_init_quantum
 240               	.LVL12:
 241               		.cfi_endproc
 242               	.LFE113:
 244               		.section	.text.matrix_power_up,"ax",@progbits
 245               	.global	matrix_power_up
 247               	matrix_power_up:
 248               	.LFB114:
 128:keyboards/split70/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 249               		.loc 1 128 0
 250               		.cfi_startproc
 251               	/* prologue: function */
 252               	/* frame size = 0 */
 253               	/* stack size = 0 */
 254               	.L__stack_usage = 0
 129:keyboards/split70/ez/matrix.c **** 
 255               		.loc 1 129 0
 256 0000 0E94 0000 		call init_mcp23018
 257               	.LVL13:
 258 0004 8093 0000 		sts mcp23018_status,r24
 131:keyboards/split70/ez/matrix.c ****     init_cols();
 259               		.loc 1 131 0
 260 0008 0E94 0000 		call unselect_rows
 261               	.LVL14:
 132:keyboards/split70/ez/matrix.c **** 
 262               		.loc 1 132 0
 263 000c 0E94 0000 		call init_cols
 264               	.LVL15:
 265 0010 E0E0      		ldi r30,lo8(matrix)
 266 0012 F0E0      		ldi r31,hi8(matrix)
 267 0014 A0E0      		ldi r26,lo8(matrix_debouncing)
 268 0016 B0E0      		ldi r27,hi8(matrix_debouncing)
 269               	.LVL16:
 270               	.L17:
 271               	.LBB10:
 136:keyboards/split70/ez/matrix.c ****         matrix_debouncing[i] = 0;
 272               		.loc 1 136 0 discriminator 3
 273 0018 1192      		st Z+,__zero_reg__
 274               	.LVL17:
 137:keyboards/split70/ez/matrix.c ****     }
 275               		.loc 1 137 0 discriminator 3
 276 001a 1D92      		st X+,__zero_reg__
 277               	.LVL18:
 135:keyboards/split70/ez/matrix.c ****         matrix[i] = 0;
 278               		.loc 1 135 0 discriminator 3
 279 001c 80E0      		ldi r24,hi8(matrix+12)
 280 001e E030      		cpi r30,lo8(matrix+12)
 281 0020 F807      		cpc r31,r24
 282 0022 01F4      		brne .L17
 283               	/* epilogue start */
 284               	.LBE10:
 145:keyboards/split70/ez/matrix.c **** 
 285               		.loc 1 145 0
 286 0024 0895      		ret
 287               		.cfi_endproc
 288               	.LFE114:
 290               		.section	.text.matrix_scan,"ax",@progbits
 291               	.global	matrix_scan
 293               	matrix_scan:
 294               	.LFB115:
 148:keyboards/split70/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 295               		.loc 1 148 0
 296               		.cfi_startproc
 297 0000 AF92      		push r10
 298               	.LCFI0:
 299               		.cfi_def_cfa_offset 3
 300               		.cfi_offset 10, -2
 301 0002 BF92      		push r11
 302               	.LCFI1:
 303               		.cfi_def_cfa_offset 4
 304               		.cfi_offset 11, -3
 305 0004 CF92      		push r12
 306               	.LCFI2:
 307               		.cfi_def_cfa_offset 5
 308               		.cfi_offset 12, -4
 309 0006 DF92      		push r13
 310               	.LCFI3:
 311               		.cfi_def_cfa_offset 6
 312               		.cfi_offset 13, -5
 313 0008 EF92      		push r14
 314               	.LCFI4:
 315               		.cfi_def_cfa_offset 7
 316               		.cfi_offset 14, -6
 317 000a FF92      		push r15
 318               	.LCFI5:
 319               		.cfi_def_cfa_offset 8
 320               		.cfi_offset 15, -7
 321 000c 0F93      		push r16
 322               	.LCFI6:
 323               		.cfi_def_cfa_offset 9
 324               		.cfi_offset 16, -8
 325 000e 1F93      		push r17
 326               	.LCFI7:
 327               		.cfi_def_cfa_offset 10
 328               		.cfi_offset 17, -9
 329 0010 CF93      		push r28
 330               	.LCFI8:
 331               		.cfi_def_cfa_offset 11
 332               		.cfi_offset 28, -10
 333 0012 DF93      		push r29
 334               	.LCFI9:
 335               		.cfi_def_cfa_offset 12
 336               		.cfi_offset 29, -11
 337               	/* prologue: function */
 338               	/* frame size = 0 */
 339               	/* stack size = 10 */
 340               	.L__stack_usage = 10
 149:keyboards/split70/ez/matrix.c ****         if (++mcp23018_reset_loop == 0) {
 341               		.loc 1 149 0
 342 0014 8091 0000 		lds r24,mcp23018_status
 343 0018 8823      		tst r24
 344 001a 01F0      		breq .L21
 150:keyboards/split70/ez/matrix.c ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
 345               		.loc 1 150 0
 346 001c 8091 0000 		lds r24,mcp23018_reset_loop
 347 0020 8F5F      		subi r24,lo8(-(1))
 348 0022 8093 0000 		sts mcp23018_reset_loop,r24
 349 0026 8111      		cpse r24,__zero_reg__
 350 0028 00C0      		rjmp .L21
 154:keyboards/split70/ez/matrix.c ****             if (mcp23018_status) {
 351               		.loc 1 154 0
 352 002a 0E94 0000 		call init_mcp23018
 353               	.LVL19:
 354 002e 8093 0000 		sts mcp23018_status,r24
 355               	.L21:
 356 0032 80E0      		ldi r24,lo8(matrix_debouncing)
 357 0034 E82E      		mov r14,r24
 358 0036 80E0      		ldi r24,hi8(matrix_debouncing)
 359 0038 F82E      		mov r15,r24
 148:keyboards/split70/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 360               		.loc 1 148 0
 361 003a 6701      		movw r12,r14
 362 003c 10E0      		ldi r17,0
 363 003e 00E0      		ldi r16,0
 364               	.LBB23:
 365               	.LBB24:
 366               	.LBB25:
 367               	.LBB26:
 326:keyboards/split70/ez/matrix.c **** 
 327:keyboards/split70/ez/matrix.c **** static void select_row(uint8_t row)
 328:keyboards/split70/ez/matrix.c **** {
 329:keyboards/split70/ez/matrix.c ****     if (row < 6) {
 330:keyboards/split70/ez/matrix.c ****         // select on mcp23018
 331:keyboards/split70/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 332:keyboards/split70/ez/matrix.c ****             // do nothing
 333:keyboards/split70/ez/matrix.c ****         } else {
 334:keyboards/split70/ez/matrix.c ****             // set active row low  : 0
 335:keyboards/split70/ez/matrix.c ****             // set other rows hi-Z : 1
 336:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);        if (mcp23018_status) goto out;
 337:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 338:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row)
 368               		.loc 1 338 0
 369 0040 AA24      		clr r10
 370 0042 A394      		inc r10
 371 0044 B12C      		mov r11,__zero_reg__
 372               	.LBE26:
 373               	.LBE25:
 186:keyboards/split70/ez/matrix.c ****         }
 374               		.loc 1 186 0
 375 0046 D5E0      		ldi r29,lo8(5)
 376               	.L46:
 377 0048 C02F      		mov r28,r16
 378               	.LVL20:
 379               	.LBB29:
 380               	.LBB27:
 329:keyboards/split70/ez/matrix.c ****         // select on mcp23018
 381               		.loc 1 329 0
 382 004a 0630      		cpi r16,lo8(6)
 383 004c 00F0      		brlo .+2
 384 004e 00C0      		rjmp .L23
 331:keyboards/split70/ez/matrix.c ****             // do nothing
 385               		.loc 1 331 0
 386 0050 8091 0000 		lds r24,mcp23018_status
 387 0054 8111      		cpse r24,__zero_reg__
 388 0056 00C0      		rjmp .L24
 336:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 389               		.loc 1 336 0
 390 0058 80E4      		ldi r24,lo8(64)
 391 005a 0E94 0000 		call i2c_start
 392               	.LVL21:
 393 005e 8093 0000 		sts mcp23018_status,r24
 394 0062 8111      		cpse r24,__zero_reg__
 395 0064 00C0      		rjmp .L26
 337:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row)
 396               		.loc 1 337 0
 397 0066 82E1      		ldi r24,lo8(18)
 398 0068 0E94 0000 		call i2c_write
 399               	.LVL22:
 400 006c 8093 0000 		sts mcp23018_status,r24
 401 0070 8111      		cpse r24,__zero_reg__
 402 0072 00C0      		rjmp .L26
 403               		.loc 1 338 0
 404 0074 C501      		movw r24,r10
 405 0076 002E      		mov r0,r16
 406 0078 00C0      		rjmp 2f
 407               		1:
 408 007a 880F      		lsl r24
 409               		2:
 410 007c 0A94      		dec r0
 411 007e 02F4      		brpl 1b
 412 0080 8095      		com r24
 413 0082 0E94 0000 		call i2c_write
 414               	.LVL23:
 415 0086 8093 0000 		sts mcp23018_status,r24
 416               	.L26:
 339:keyboards/split70/ez/matrix.c ****                                   & ~(0<<6)
 340:keyboards/split70/ez/matrix.c ****                               );                                if (mcp23018_status) goto out;
 341:keyboards/split70/ez/matrix.c ****         out:
 342:keyboards/split70/ez/matrix.c ****             i2c_stop();
 417               		.loc 1 342 0
 418 008a 0E94 0000 		call i2c_stop
 419               	.LVL24:
 420               	.L24:
 421               	.LBE27:
 422               	.LBE29:
 423               	.LBB30:
 424               	.LBB31:
 425               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 426               		.loc 2 276 0
 427 008e 80EA      		ldi r24,lo8(-96)
 428 0090 8A95      	1:	dec r24
 429 0092 01F4      		brne 1b
 430               	.LVL25:
 431               	.LBE31:
 432               	.LBE30:
 433               	.LBB32:
 434               	.LBB33:
 267:keyboards/split70/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 435               		.loc 1 267 0
 436 0094 C730      		cpi r28,lo8(7)
 437 0096 00F0      		brlo .+2
 438 0098 00C0      		rjmp .L35
 268:keyboards/split70/ez/matrix.c ****             return 0;
 439               		.loc 1 268 0
 440 009a C091 0000 		lds r28,mcp23018_status
 441 009e C111      		cpse r28,__zero_reg__
 442 00a0 00C0      		rjmp .L51
 443               	.LVL26:
 444               	.LBB34:
 272:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 445               		.loc 1 272 0
 446 00a2 80E4      		ldi r24,lo8(64)
 447 00a4 0E94 0000 		call i2c_start
 448               	.LVL27:
 449 00a8 8093 0000 		sts mcp23018_status,r24
 450 00ac 8111      		cpse r24,__zero_reg__
 451 00ae 00C0      		rjmp .L38
 273:keyboards/split70/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 452               		.loc 1 273 0
 453 00b0 83E1      		ldi r24,lo8(19)
 454 00b2 0E94 0000 		call i2c_write
 455               	.LVL28:
 456 00b6 8093 0000 		sts mcp23018_status,r24
 457 00ba 8111      		cpse r24,__zero_reg__
 458 00bc 00C0      		rjmp .L38
 274:keyboards/split70/ez/matrix.c ****             data = i2c_readNak();
 459               		.loc 1 274 0
 460 00be 81E4      		ldi r24,lo8(65)
 461 00c0 0E94 0000 		call i2c_start
 462               	.LVL29:
 463 00c4 8093 0000 		sts mcp23018_status,r24
 464 00c8 8111      		cpse r24,__zero_reg__
 465 00ca 00C0      		rjmp .L38
 275:keyboards/split70/ez/matrix.c ****             data = ~data;
 466               		.loc 1 275 0
 467 00cc 0E94 0000 		call i2c_readNak
 468               	.LVL30:
 276:keyboards/split70/ez/matrix.c ****         out:
 469               		.loc 1 276 0
 470 00d0 C82F      		mov r28,r24
 471 00d2 C095      		com r28
 472               	.LVL31:
 473               	.L38:
 278:keyboards/split70/ez/matrix.c ****             return data;
 474               		.loc 1 278 0
 475 00d4 0E94 0000 		call i2c_stop
 476               	.LVL32:
 477               	.L36:
 478               	.LBE34:
 479               	.LBE33:
 480               	.LBE32:
 181:keyboards/split70/ez/matrix.c ****             matrix_debouncing[i] = cols;
 481               		.loc 1 181 0
 482 00d8 D601      		movw r26,r12
 483 00da 8D91      		ld r24,X+
 484 00dc 6D01      		movw r12,r26
 485 00de 8C17      		cp r24,r28
 486 00e0 01F0      		breq .L45
 182:keyboards/split70/ez/matrix.c ****             if (debouncing) {
 487               		.loc 1 182 0
 488 00e2 FD01      		movw r30,r26
 489 00e4 3197      		sbiw r30,1
 490 00e6 C083      		st Z,r28
 186:keyboards/split70/ez/matrix.c ****         }
 491               		.loc 1 186 0
 492 00e8 D093 0000 		sts debouncing,r29
 493               	.L45:
 188:keyboards/split70/ez/matrix.c ****     }
 494               		.loc 1 188 0 discriminator 2
 495 00ec 0E94 0000 		call unselect_rows
 496               	.LVL33:
 497 00f0 0F5F      		subi r16,-1
 498 00f2 1F4F      		sbci r17,-1
 499               	.LVL34:
 500               	.LBE24:
 177:keyboards/split70/ez/matrix.c ****         select_row(i);
 501               		.loc 1 177 0 discriminator 2
 502 00f4 0C30      		cpi r16,12
 503 00f6 1105      		cpc r17,__zero_reg__
 504 00f8 01F0      		breq .+2
 505 00fa 00C0      		rjmp .L46
 506               	.LBE23:
 191:keyboards/split70/ez/matrix.c ****         if (--debouncing) {
 507               		.loc 1 191 0
 508 00fc 8091 0000 		lds r24,debouncing
 509 0100 8823      		tst r24
 510 0102 01F0      		breq .L49
 192:keyboards/split70/ez/matrix.c ****             wait_us(1);
 511               		.loc 1 192 0
 512 0104 8150      		subi r24,lo8(-(-1))
 513 0106 8093 0000 		sts debouncing,r24
 514 010a 8823      		tst r24
 515 010c 01F4      		brne .+2
 516 010e 00C0      		rjmp .L48
 517               	.LVL35:
 518               	.LBB39:
 519               	.LBB40:
 520               		.loc 2 276 0
 521 0110 B5E0      		ldi r27,lo8(5)
 522 0112 BA95      	1:	dec r27
 523 0114 01F4      		brne 1b
 524 0116 0000      		nop
 525               	.LVL36:
 526               	.L49:
 527               	.LBE40:
 528               	.LBE39:
 202:keyboards/split70/ez/matrix.c **** 
 529               		.loc 1 202 0
 530 0118 0E94 0000 		call matrix_scan_quantum
 531               	.LVL37:
 205:keyboards/split70/ez/matrix.c **** 
 532               		.loc 1 205 0
 533 011c 81E0      		ldi r24,lo8(1)
 534               	/* epilogue start */
 535 011e DF91      		pop r29
 536 0120 CF91      		pop r28
 537 0122 1F91      		pop r17
 538 0124 0F91      		pop r16
 539               	.LVL38:
 540 0126 FF90      		pop r15
 541 0128 EF90      		pop r14
 542 012a DF90      		pop r13
 543 012c CF90      		pop r12
 544 012e BF90      		pop r11
 545 0130 AF90      		pop r10
 546 0132 0895      		ret
 547               	.LVL39:
 548               	.L23:
 549               	.LBB41:
 550               	.LBB38:
 551               	.LBB36:
 552               	.LBB28:
 343:keyboards/split70/ez/matrix.c ****         }
 344:keyboards/split70/ez/matrix.c ****     } else {
 345:keyboards/split70/ez/matrix.c ****         // select on teensy
 346:keyboards/split70/ez/matrix.c ****         // Output low(DDR:1, PORT:0) to select
 347:keyboards/split70/ez/matrix.c ****         switch (row) {
 553               		.loc 1 347 0
 554 0134 0930      		cpi r16,lo8(9)
 555 0136 01F0      		breq .L29
 556 0138 00F4      		brsh .L30
 557 013a 0730      		cpi r16,lo8(7)
 558 013c 01F0      		breq .L31
 559 013e 0830      		cpi r16,lo8(8)
 560 0140 01F0      		breq .L32
 561               	.L28:
 348:keyboards/split70/ez/matrix.c ****             case 6:
 349:keyboards/split70/ez/matrix.c ****                 DDRB  |= (1<<0);
 562               		.loc 1 349 0
 563 0142 209A      		sbi 0x4,0
 350:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<0);
 564               		.loc 1 350 0
 565 0144 2898      		cbi 0x5,0
 566 0146 00C0      		rjmp .L24
 567               	.L30:
 347:keyboards/split70/ez/matrix.c ****             case 6:
 568               		.loc 1 347 0
 569 0148 0A30      		cpi r16,lo8(10)
 570 014a 01F0      		breq .L33
 571 014c 0B30      		cpi r16,lo8(11)
 572 014e 01F4      		brne .L28
 351:keyboards/split70/ez/matrix.c ****                 break;
 352:keyboards/split70/ez/matrix.c ****             case 7:
 353:keyboards/split70/ez/matrix.c ****                 DDRB  |= (1<<1);
 354:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<1);
 355:keyboards/split70/ez/matrix.c ****                 break;
 356:keyboards/split70/ez/matrix.c ****             case 8:
 357:keyboards/split70/ez/matrix.c ****                 DDRB  |= (1<<2);
 358:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<2);
 359:keyboards/split70/ez/matrix.c ****                 break;
 360:keyboards/split70/ez/matrix.c ****             case 9:
 361:keyboards/split70/ez/matrix.c ****                 DDRB  |= (1<<3);
 362:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<3);
 363:keyboards/split70/ez/matrix.c ****                 break;
 364:keyboards/split70/ez/matrix.c ****             case 10:
 365:keyboards/split70/ez/matrix.c ****                 DDRD  |= (1<<2);
 366:keyboards/split70/ez/matrix.c ****                 PORTD &= ~(1<<2);
 367:keyboards/split70/ez/matrix.c ****                 break;
 368:keyboards/split70/ez/matrix.c ****             case 11:
 369:keyboards/split70/ez/matrix.c ****                 DDRD  |= (1<<3);
 573               		.loc 1 369 0
 574 0150 539A      		sbi 0xa,3
 370:keyboards/split70/ez/matrix.c ****                 PORTD &= ~(1<<3);
 575               		.loc 1 370 0
 576 0152 5B98      		cbi 0xb,3
 577 0154 00C0      		rjmp .L24
 578               	.L31:
 353:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<1);
 579               		.loc 1 353 0
 580 0156 219A      		sbi 0x4,1
 354:keyboards/split70/ez/matrix.c ****                 break;
 581               		.loc 1 354 0
 582 0158 2998      		cbi 0x5,1
 583 015a 00C0      		rjmp .L24
 584               	.L32:
 357:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<2);
 585               		.loc 1 357 0
 586 015c 229A      		sbi 0x4,2
 358:keyboards/split70/ez/matrix.c ****                 break;
 587               		.loc 1 358 0
 588 015e 2A98      		cbi 0x5,2
 589 0160 00C0      		rjmp .L24
 590               	.L29:
 361:keyboards/split70/ez/matrix.c ****                 PORTB &= ~(1<<3);
 591               		.loc 1 361 0
 592 0162 239A      		sbi 0x4,3
 362:keyboards/split70/ez/matrix.c ****                 break;
 593               		.loc 1 362 0
 594 0164 2B98      		cbi 0x5,3
 595 0166 00C0      		rjmp .L24
 596               	.L33:
 365:keyboards/split70/ez/matrix.c ****                 PORTD &= ~(1<<2);
 597               		.loc 1 365 0
 598 0168 529A      		sbi 0xa,2
 366:keyboards/split70/ez/matrix.c ****                 break;
 599               		.loc 1 366 0
 600 016a 5A98      		cbi 0xb,2
 601 016c 00C0      		rjmp .L24
 602               	.LVL40:
 603               	.L35:
 604               	.LBE28:
 605               	.LBE36:
 606               	.LBB37:
 607               	.LBB35:
 284:keyboards/split70/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 608               		.loc 1 284 0
 609 016e CFB1      		in r28,0xf
 610 0170 C095      		com r28
 611 0172 C170      		andi r28,lo8(1)
 612 0174 799B      		sbis 0xf,1
 613 0176 00C0      		rjmp .L52
 614 0178 80E0      		ldi r24,0
 615               	.L40:
 616 017a C82B      		or r28,r24
 285:keyboards/split70/ez/matrix.c ****             (PINF&(1<<4) ? 0 : (1<<2)) |
 617               		.loc 1 285 0
 618 017c 7C9B      		sbis 0xf,4
 619 017e 00C0      		rjmp .L53
 620 0180 80E0      		ldi r24,0
 621               	.L41:
 622 0182 C82B      		or r28,r24
 286:keyboards/split70/ez/matrix.c ****             (PINF&(1<<5) ? 0 : (1<<3)) |
 623               		.loc 1 286 0
 624 0184 7D9B      		sbis 0xf,5
 625 0186 00C0      		rjmp .L54
 626 0188 80E0      		ldi r24,0
 627               	.L42:
 628 018a C82B      		or r28,r24
 287:keyboards/split70/ez/matrix.c ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 629               		.loc 1 287 0
 630 018c 7E9B      		sbis 0xf,6
 631 018e 00C0      		rjmp .L55
 632 0190 80E0      		ldi r24,0
 633               	.L43:
 634 0192 C82B      		or r28,r24
 288:keyboards/split70/ez/matrix.c ****             (PINF&(1<<7) ? 0 : (1<<5)) ;
 635               		.loc 1 288 0
 636 0194 7F9B      		sbis 0xf,7
 637 0196 00C0      		rjmp .L56
 638 0198 80E0      		ldi r24,0
 639               	.L44:
 640 019a C82B      		or r28,r24
 641 019c 00C0      		rjmp .L36
 642               	.L52:
 284:keyboards/split70/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 643               		.loc 1 284 0
 644 019e 82E0      		ldi r24,lo8(2)
 645 01a0 00C0      		rjmp .L40
 646               	.L53:
 285:keyboards/split70/ez/matrix.c ****             (PINF&(1<<4) ? 0 : (1<<2)) |
 647               		.loc 1 285 0
 648 01a2 84E0      		ldi r24,lo8(4)
 649 01a4 00C0      		rjmp .L41
 650               	.L54:
 286:keyboards/split70/ez/matrix.c ****             (PINF&(1<<5) ? 0 : (1<<3)) |
 651               		.loc 1 286 0
 652 01a6 88E0      		ldi r24,lo8(8)
 653 01a8 00C0      		rjmp .L42
 654               	.L55:
 287:keyboards/split70/ez/matrix.c ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 655               		.loc 1 287 0
 656 01aa 80E1      		ldi r24,lo8(16)
 657 01ac 00C0      		rjmp .L43
 658               	.L56:
 288:keyboards/split70/ez/matrix.c ****             (PINF&(1<<7) ? 0 : (1<<5)) ;
 659               		.loc 1 288 0
 660 01ae 80E2      		ldi r24,lo8(32)
 661 01b0 00C0      		rjmp .L44
 662               	.L51:
 269:keyboards/split70/ez/matrix.c ****         } else {
 663               		.loc 1 269 0
 664 01b2 C0E0      		ldi r28,0
 665 01b4 00C0      		rjmp .L36
 666               	.LVL41:
 667               	.L48:
 668 01b6 E0E0      		ldi r30,lo8(matrix)
 669 01b8 F0E0      		ldi r31,hi8(matrix)
 670 01ba 80E0      		ldi r24,lo8(matrix_debouncing+12)
 671 01bc 90E0      		ldi r25,hi8(matrix_debouncing+12)
 672               	.L50:
 673               	.LVL42:
 674               	.LBE35:
 675               	.LBE37:
 676               	.LBE38:
 677               	.LBE41:
 678               	.LBB42:
 197:keyboards/split70/ez/matrix.c ****             }
 679               		.loc 1 197 0 discriminator 3
 680 01be D701      		movw r26,r14
 681 01c0 2D91      		ld r18,X+
 682 01c2 7D01      		movw r14,r26
 683               	.LVL43:
 684 01c4 2193      		st Z+,r18
 685               	.LVL44:
 196:keyboards/split70/ez/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 686               		.loc 1 196 0 discriminator 3
 687 01c6 8A17      		cp r24,r26
 688 01c8 9B07      		cpc r25,r27
 689 01ca 01F4      		brne .L50
 690 01cc 00C0      		rjmp .L49
 691               	.LBE42:
 692               		.cfi_endproc
 693               	.LFE115:
 695               		.section	.text.matrix_is_modified,"ax",@progbits
 696               	.global	matrix_is_modified
 698               	matrix_is_modified:
 699               	.LFB116:
 208:keyboards/split70/ez/matrix.c ****     if (debouncing) return false;
 700               		.loc 1 208 0
 701               		.cfi_startproc
 702               	/* prologue: function */
 703               	/* frame size = 0 */
 704               	/* stack size = 0 */
 705               	.L__stack_usage = 0
 209:keyboards/split70/ez/matrix.c ****     return true;
 706               		.loc 1 209 0
 707 0000 81E0      		ldi r24,lo8(1)
 708 0002 9091 0000 		lds r25,debouncing
 709 0006 9111      		cpse r25,__zero_reg__
 710 0008 80E0      		ldi r24,0
 711               	.L63:
 712               	/* epilogue start */
 211:keyboards/split70/ez/matrix.c **** 
 713               		.loc 1 211 0
 714 000a 0895      		ret
 715               		.cfi_endproc
 716               	.LFE116:
 718               		.section	.text.matrix_is_on,"ax",@progbits
 719               	.global	matrix_is_on
 721               	matrix_is_on:
 722               	.LFB117:
 215:keyboards/split70/ez/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 723               		.loc 1 215 0
 724               		.cfi_startproc
 725               	.LVL45:
 726               	/* prologue: function */
 727               	/* frame size = 0 */
 728               	/* stack size = 0 */
 729               	.L__stack_usage = 0
 216:keyboards/split70/ez/matrix.c **** }
 730               		.loc 1 216 0
 731 0000 E82F      		mov r30,r24
 732 0002 F0E0      		ldi r31,0
 733 0004 E050      		subi r30,lo8(-(matrix))
 734 0006 F040      		sbci r31,hi8(-(matrix))
 735 0008 2081      		ld r18,Z
 736 000a 30E0      		ldi r19,0
 737 000c 81E0      		ldi r24,lo8(1)
 738 000e 90E0      		ldi r25,0
 739               	.LVL46:
 740 0010 00C0      		rjmp 2f
 741               		1:
 742 0012 880F      		lsl r24
 743 0014 991F      		rol r25
 744               		2:
 745 0016 6A95      		dec r22
 746 0018 02F4      		brpl 1b
 747 001a 2823      		and r18,r24
 748 001c 3923      		and r19,r25
 749 001e 81E0      		ldi r24,lo8(1)
 750 0020 232B      		or r18,r19
 751 0022 01F4      		brne .L68
 752 0024 80E0      		ldi r24,0
 753               	.L68:
 754               	/* epilogue start */
 217:keyboards/split70/ez/matrix.c **** 
 755               		.loc 1 217 0
 756 0026 0895      		ret
 757               		.cfi_endproc
 758               	.LFE117:
 760               		.section	.text.matrix_get_row,"ax",@progbits
 761               	.global	matrix_get_row
 763               	matrix_get_row:
 764               	.LFB118:
 221:keyboards/split70/ez/matrix.c ****     return matrix[row];
 765               		.loc 1 221 0
 766               		.cfi_startproc
 767               	.LVL47:
 768               	/* prologue: function */
 769               	/* frame size = 0 */
 770               	/* stack size = 0 */
 771               	.L__stack_usage = 0
 222:keyboards/split70/ez/matrix.c **** }
 772               		.loc 1 222 0
 773 0000 E82F      		mov r30,r24
 774 0002 F0E0      		ldi r31,0
 775 0004 E050      		subi r30,lo8(-(matrix))
 776 0006 F040      		sbci r31,hi8(-(matrix))
 223:keyboards/split70/ez/matrix.c **** 
 777               		.loc 1 223 0
 778 0008 8081      		ld r24,Z
 779               	.LVL48:
 780               	/* epilogue start */
 781 000a 0895      		ret
 782               		.cfi_endproc
 783               	.LFE118:
 785               		.section	.text.matrix_print,"ax",@progbits
 786               	.global	matrix_print
 788               	matrix_print:
 789               	.LFB119:
 226:keyboards/split70/ez/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 790               		.loc 1 226 0
 791               		.cfi_startproc
 792               	/* prologue: function */
 793               	/* frame size = 0 */
 794               	/* stack size = 0 */
 795               	.L__stack_usage = 0
 796               	.LVL49:
 797               	/* epilogue start */
 233:keyboards/split70/ez/matrix.c **** 
 798               		.loc 1 233 0
 799 0000 0895      		ret
 800               		.cfi_endproc
 801               	.LFE119:
 803               		.section	.text.matrix_key_count,"ax",@progbits
 804               	.global	matrix_key_count
 806               	matrix_key_count:
 807               	.LFB120:
 236:keyboards/split70/ez/matrix.c ****     uint8_t count = 0;
 808               		.loc 1 236 0
 809               		.cfi_startproc
 810 0000 0F93      		push r16
 811               	.LCFI10:
 812               		.cfi_def_cfa_offset 3
 813               		.cfi_offset 16, -2
 814 0002 1F93      		push r17
 815               	.LCFI11:
 816               		.cfi_def_cfa_offset 4
 817               		.cfi_offset 17, -3
 818 0004 CF93      		push r28
 819               	.LCFI12:
 820               		.cfi_def_cfa_offset 5
 821               		.cfi_offset 28, -4
 822               	/* prologue: function */
 823               	/* frame size = 0 */
 824               	/* stack size = 3 */
 825               	.L__stack_usage = 3
 826               	.LVL50:
 827 0006 00E0      		ldi r16,lo8(matrix)
 828 0008 10E0      		ldi r17,hi8(matrix)
 237:keyboards/split70/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 829               		.loc 1 237 0
 830 000a C0E0      		ldi r28,0
 831               	.LVL51:
 832               	.L72:
 833               	.LBB43:
 239:keyboards/split70/ez/matrix.c ****     }
 834               		.loc 1 239 0 discriminator 3
 835 000c F801      		movw r30,r16
 836 000e 8191      		ld r24,Z+
 837 0010 8F01      		movw r16,r30
 838               	.LVL52:
 839 0012 90E0      		ldi r25,0
 840 0014 0E94 0000 		call bitpop16
 841               	.LVL53:
 842 0018 C80F      		add r28,r24
 843               	.LVL54:
 238:keyboards/split70/ez/matrix.c ****         count += bitpop16(matrix[i]);
 844               		.loc 1 238 0 discriminator 3
 845 001a F0E0      		ldi r31,hi8(matrix+12)
 846 001c 0030      		cpi r16,lo8(matrix+12)
 847 001e 1F07      		cpc r17,r31
 848 0020 01F4      		brne .L72
 849               	.LBE43:
 242:keyboards/split70/ez/matrix.c **** 
 850               		.loc 1 242 0
 851 0022 8C2F      		mov r24,r28
 852               	/* epilogue start */
 853 0024 CF91      		pop r28
 854               	.LVL55:
 855 0026 1F91      		pop r17
 856 0028 0F91      		pop r16
 857               	.LVL56:
 858 002a 0895      		ret
 859               		.cfi_endproc
 860               	.LFE120:
 862               		.section	.bss.mcp23018_reset_loop,"aw",@nobits
 865               	mcp23018_reset_loop:
 866 0000 00        		.zero	1
 867               		.section	.bss.matrix_debouncing,"aw",@nobits
 870               	matrix_debouncing:
 871 0000 0000 0000 		.zero	12
 871      0000 0000 
 871      0000 0000 
 872               		.section	.bss.matrix,"aw",@nobits
 875               	matrix:
 876 0000 0000 0000 		.zero	12
 876      0000 0000 
 876      0000 0000 
 877               		.section	.data.debouncing,"aw",@progbits
 880               	debouncing:
 881 0000 05        		.byte	5
 882               		.text
 883               	.Letext0:
 884               		.file 3 "/usr/avr/include/stdint.h"
 885               		.file 4 "/usr/lib/gcc/avr/7.1.0/include/stddef.h"
 886               		.file 5 "./tmk_core/common/action_layer.h"
 887               		.file 6 "./tmk_core/common/debug.h"
 888               		.file 7 "./tmk_core/common/matrix.h"
 889               		.file 8 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 890               		.file 9 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 891               		.file 10 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
 892               		.file 11 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/HostStandardReq.h"
 893               		.file 12 "/usr/avr/include/stdio.h"
 894               		.file 13 "./tmk_core/common/report.h"
 895               		.file 14 "./tmk_core/common/host.h"
 896               		.file 15 "./quantum/keycode_config.h"
 897               		.file 16 "./quantum/keymap.h"
 898               		.file 17 "./tmk_core/common/timer.h"
 899               		.file 18 "./tmk_core/common/action_util.h"
 900               		.file 19 "/usr/avr/include/stdlib.h"
 901               		.file 20 "keyboards/split70/ez/ez.h"
 902               		.file 21 "./quantum/process_keycode/process_unicode_common.h"
 903               		.file 22 "keyboards/split70/ez/i2cmaster.h"
 904               		.file 23 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccYuHddA.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccYuHddA.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccYuHddA.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccYuHddA.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccYuHddA.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccYuHddA.s:12     .text.init_cols:0000000000000000 init_cols
     /tmp/ccYuHddA.s:37     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccYuHddA.s:98     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccYuHddA.s:98     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias.0
     /tmp/ccYuHddA.s:116    .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccYuHddA.s:131    .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccYuHddA.s:148    .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccYuHddA.s:165    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccYuHddA.s:183    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccYuHddA.s:201    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccYuHddA.s:875    .bss.matrix:0000000000000000 matrix
     /tmp/ccYuHddA.s:870    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccYuHddA.s:247    .text.matrix_power_up:0000000000000000 matrix_power_up
     /tmp/ccYuHddA.s:293    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccYuHddA.s:865    .bss.mcp23018_reset_loop:0000000000000000 mcp23018_reset_loop
     /tmp/ccYuHddA.s:880    .data.debouncing:0000000000000000 debouncing
     /tmp/ccYuHddA.s:698    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccYuHddA.s:721    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccYuHddA.s:763    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccYuHddA.s:788    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccYuHddA.s:806    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
mcp23018_status
i2c_start
i2c_write
i2c_stop
init_mcp23018
matrix_init_quantum
i2c_readNak
matrix_scan_quantum
bitpop16
__do_copy_data
__do_clear_bss
